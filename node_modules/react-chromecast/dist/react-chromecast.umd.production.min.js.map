{"version":3,"file":"react-chromecast.umd.production.min.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/context/castContext.ts","../src/components/CastProvider.tsx","../src/helpers/toWait.ts","../src/hooks/useCast.ts","../src/hooks/useMedia.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { createContext } from \"react\";\r\n\r\nimport CastReceiver from \"../interfaces/CastReceiver\";\r\n\r\nconst castContext = createContext<{\r\n  castReceiver?: CastReceiver;\r\n  castSender?: any;\r\n  setSession?: (p: any) => void;\r\n  session?: any;\r\n}>({});\r\n\r\nexport default castContext;\r\n","import * as React from 'react';\r\n\r\nimport { Helmet } from 'react-helmet';\r\nimport castContext from '../context/castContext';\r\n\r\nimport CastReceiver from '../interfaces/CastReceiver';\r\n\r\nimport toWait from '../helpers/toWait';\r\n\r\nconst { useState, useEffect } = React;\r\n\r\n/**\r\n * CastProvider is a component to use arround every component you go use with `react-chromecast` hooks\r\n *\r\n * Ex:\r\n * ```jsx\r\n *  import CastProvider from 'react-chromecast'\r\n *  function App () {\r\n *    return (\r\n *      <CastProvider>\r\n *        {\r\n *          // your components using react-chromecast hooks goes here\r\n *        }\r\n *      </CastProvider>\r\n *    )\r\n *  }\r\n * ```\r\n */\r\nfunction CastProvider({ children }: { children: any }) {\r\n  const [cast, setCast] = useState<{\r\n    castReceiver?: CastReceiver;\r\n    castSender?: any;\r\n  }>({});\r\n  const [session, setSession] = useState<any>({});\r\n  useEffect(() => {\r\n    (async () => {\r\n      let toBreak = false;\r\n      let tries = 15;\r\n      let castReceiver: CastReceiver;\r\n      let castSender: any;\r\n      while (true) {\r\n        try {\r\n          // @ts-ignore\r\n          castReceiver = window.chrome.cast as CastReceiver;\r\n          // @ts-ignore\r\n          castSender = window.cast.framework as any;\r\n          toBreak = true;\r\n        } catch (err) {\r\n          tries--;\r\n          if (!tries) {\r\n            toBreak = true;\r\n          }\r\n        } finally {\r\n          if (toBreak) break;\r\n        }\r\n        await toWait(95);\r\n      }\r\n      // @ts-ignore\r\n      if (tries !== 0 && !!castReceiver) {\r\n        setCast({\r\n          castReceiver,\r\n          castSender,\r\n        });\r\n      } else {\r\n        throw new Error(\"Can't Load castReceiver and\\\\or castSender\");\r\n      }\r\n    })();\r\n  }, []);\r\n  return (\r\n    <>\r\n      <Helmet>\r\n        <script src=\"//www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1\" />\r\n        <script src=\"//www.gstatic.com/cast/sdk/libs/receiver/2.0.0/cast_receiver.js\" />\r\n      </Helmet>\r\n      <castContext.Provider\r\n        value={{\r\n          ...cast,\r\n          session,\r\n          setSession,\r\n        }}\r\n      >\r\n        {children}\r\n      </castContext.Provider>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default CastProvider;\r\n","const wait = (time: number) =>\r\n  new Promise(res => {\r\n    setTimeout(res, time);\r\n  });\r\n\r\nexport default wait;\r\n","import { useEffect, useContext, useCallback, useState } from \"react\";\r\n\r\nimport castCtx from \"../context/castContext\";\r\n\r\nimport CastReceiver from \"../interfaces/CastReceiver\";\r\n\r\ninterface Props {\r\n  /**\r\n   * @param initialize_media_player - is media_receiver id\r\n   *\r\n   * if you pass auto_initialize as true you should pass this\r\n   *\r\n   * you should pass media_receiver id or 'DEFAULT_MEDIA_RECEIVER_APP_ID' to use default media receiver\r\n   */\r\n  initialize_media_player?: string;\r\n  /**\r\n   * @param auto_initialize - you can use this to auto initialize cast media player when castReceiver was define\r\n   *\r\n   * you not need to pass nothing to this if you go initialize by yourself\r\n   */\r\n  auto_initialize?: boolean;\r\n}\r\n\r\ninterface Cast {\r\n  /**\r\n   * Function to initialize cast player before connect to chromecast\r\n   *\r\n   * This function should wait for castReceiver\r\n   *\r\n   * @param media_player - you should pass media_receiver id or 'DEFAULT_MEDIA_RECEIVER_APP_ID' to use default media receiver\r\n   *\r\n   * Example:\r\n   * ```jsx\r\n   *  const cast = useCast()\r\n   *  useEffect(() => {\r\n   *    if(cast.castReceiver){\r\n   *      cast.initializeCast('DEFAULT_MEDIA_RECEIVER_APP_ID')\r\n   *    }\r\n   *  }, [cast.castReceiver])\r\n   * ```\r\n   */\r\n  initializeCast?: (media_player: string) => void;\r\n  /**\r\n   * Function to connect and disconnect client to chromecast\r\n   */\r\n  handleConnection: () => Promise<any>;\r\n  /**\r\n   * castReceiver object, from cast_receiver google lib\r\n   */\r\n  castReceiver?: CastReceiver;\r\n  /**\r\n   * castSender object, from cast_sender google lib\r\n   */\r\n  castSender?: any;\r\n  /**\r\n   * this inidicate if client is connected with chromecast or not\r\n   */\r\n  isConnect: boolean;\r\n}\r\n\r\nfunction useCast(props?: Props) {\r\n  const { initialize_media_player, auto_initialize } = props || {};\r\n\r\n  const { castReceiver, castSender, setSession } = useContext(castCtx);\r\n  const [cast, setCast] = useState({});\r\n  const [isConnect, setIsConnect] = useState(false);\r\n  const initiliazeCast = useCallback(\r\n    (media_player: string) => {\r\n      if (!castReceiver) return;\r\n      const sessionRequest = new castReceiver.SessionRequest(\r\n        castReceiver.media[media_player]\r\n      );\r\n      const apiConfig = new castReceiver.ApiConfig(\r\n        // @ts-ignore\r\n        sessionRequest,\r\n        (e: any) => {\r\n          // console.log(\"ss listener\", e);\r\n          if (setSession) setSession(e);\r\n          setIsConnect(true);\r\n        },\r\n        (e: any) => {\r\n          // console.log(\"rc listener\", e);\r\n        }\r\n      );\r\n      castReceiver.initialize(\r\n        apiConfig,\r\n        (e: any) => {\r\n          // console.log(\"init success\", e);\r\n        },\r\n        (e: any) => {\r\n          // console.log(\"init error\", e);\r\n        }\r\n      );\r\n      setCast({\r\n        castReceiver,\r\n      });\r\n    },\r\n    [castReceiver, setSession]\r\n  );\r\n\r\n  const handleConnection = useCallback(\r\n    () =>\r\n      new Promise((res, rej) => {\r\n        if (castReceiver) {\r\n          // @ts-ignore\r\n          castReceiver.requestSession(\r\n            (e: any) => {\r\n              if (setSession) setSession(e);\r\n              setIsConnect(true);\r\n              res(e);\r\n            },\r\n            (e: any) => {\r\n              setIsConnect(false);\r\n              if (!isConnect) return rej(e);\r\n              return res(null);\r\n            }\r\n          );\r\n        }\r\n      }),\r\n    [castReceiver, setSession]\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (castReceiver) {\r\n      setCast({ castReceiver });\r\n      if (auto_initialize && !initialize_media_player)\r\n        throw new Error(\r\n          \"if you pass auto_initialize: true, you should pass initialize_media_player\"\r\n        );\r\n      else if (auto_initialize && initialize_media_player)\r\n        initiliazeCast(initialize_media_player);\r\n    }\r\n  }, [castReceiver, castSender]);\r\n\r\n  const Cast = { ...cast, handleConnection, isConnect } as Cast;\r\n\r\n  if (!auto_initialize) {\r\n    Cast[\"initializeCast\"] = initiliazeCast;\r\n  }\r\n\r\n  return Cast;\r\n}\r\n\r\nexport default useCast;\r\n","import { useCallback, useContext, useState, useEffect } from \"react\";\r\n\r\nimport castCtx from \"../context/castContext\";\r\n\r\ninterface Media {\r\n  /**\r\n   * @function playMedia - function to add an media url to chromecast to play, you should use this to first media before add more with the add function, and before use play function\r\n   * @param src - this should be an media url acessible by chromecast\r\n   * @param autoplay - this inidicate if media will play after defined, default is true\r\n   */\r\n  playMedia: (src: string, autoplay?: boolean) => Promise<any>;\r\n  /**\r\n   * @function addMedia - function to add an media url to chromecast queue\r\n   * @param src - this should be an media url acessible by chromecast\r\n   */\r\n  addMedia: (src: string) => Promise<any>;\r\n  /**\r\n   * @function play - function to play media in chromecast\r\n   */\r\n  play: () => Promise<any>;\r\n  /**\r\n   * @function pause - function to pause media in chromecast\r\n   */\r\n  pause: () => Promise<any>;\r\n  /**\r\n   * this inidicate if is a media connected to chromecast\r\n   */\r\n  isMedia: boolean;\r\n  /**\r\n   * @function next - function to jump to next video in chromecast queue\r\n   */\r\n  next: () => Promise<any>;\r\n  /**\r\n   * @function prev - function to jump to prev video in chromecast queue\r\n   */\r\n  prev: () => Promise<any>;\r\n  /**\r\n   * @function to - function to jump to the time passed in seconds in chromecast playing video\r\n   * @param seconds - time in seconds to jump to\r\n   */\r\n  to: (seconds: number) => Promise<any>;\r\n}\r\n\r\nfunction useMedia() {\r\n  const { session, castReceiver } = useContext(castCtx);\r\n  const [media, setMedia] = useState<any>(null);\r\n  const [isMedia, setIsMedia] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (!session && isMedia) setIsMedia(false);\r\n  }, [session, isMedia]);\r\n\r\n  const playMedia = useCallback(\r\n    (src: string, autoplay?: boolean) =>\r\n      new Promise((res, rej) => {\r\n        if (!castReceiver || !session)\r\n          return rej(new Error(\"An Error occurred\"));\r\n\r\n        // @ts-ignore\r\n        const mediaInfo = new castReceiver.media.MediaInfo(src);\r\n        // @ts-ignore\r\n        const request = new castReceiver.media.LoadRequest(mediaInfo);\r\n\r\n        request.autoplay = autoplay || true;\r\n        session.loadMedia(\r\n          request,\r\n          (media: any) => {\r\n            setMedia(media);\r\n            setIsMedia(true);\r\n            res(media);\r\n          },\r\n          (err: any) => rej(err)\r\n        );\r\n      }),\r\n    [castReceiver, session]\r\n  );\r\n\r\n  const addMedia = useCallback(\r\n    async (src: string) => {\r\n      if (!castReceiver && !media) return;\r\n      // @ts-ignore\r\n      const mediaInfo = new castReceiver.media.MediaInfo(src);\r\n      // @ts-ignore\r\n      const queueItem = new castReceiver.media.QueueItem(mediaInfo);\r\n      await media.queueAppendItem(queueItem);\r\n    },\r\n    [media, castReceiver]\r\n  );\r\n\r\n  const play = useCallback(async () => {\r\n    if (!media) return;\r\n    await media.play();\r\n  }, [media]);\r\n\r\n  const pause = useCallback(async () => {\r\n    if (!media) return;\r\n    await media.pause();\r\n  }, [media]);\r\n\r\n  const prev = useCallback(async () => {\r\n    if (!media) return;\r\n    await media.queuePrev();\r\n  }, [media]);\r\n\r\n  const next = useCallback(async () => {\r\n    if (!media) return;\r\n    await media.queueNext();\r\n  }, [media]);\r\n\r\n  const to = useCallback(\r\n    async (seconds: number) => {\r\n      if (!media && !castReceiver) return;\r\n\r\n      // @ts-ignore\r\n      const seek = new castReceiver.media.SeekRequest();\r\n\r\n      seek.currentTime = seconds;\r\n\r\n      await media.seek(seek);\r\n    },\r\n    [media, castReceiver]\r\n  );\r\n\r\n  return {\r\n    playMedia,\r\n    addMedia,\r\n    play,\r\n    pause,\r\n    isMedia,\r\n    next,\r\n    prev,\r\n    to,\r\n  } as Media;\r\n}\r\n\r\nexport default useMedia;\r\n"],"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_isSettledPact","thenable","Symbol","iterator","asyncIterator","castContext","createContext","useState","React","useEffect","children","cast","setCast","session","setSession","castReceiver","castSender","tries","Error","toBreak","test","update","body","stage","shouldContinue","reject","_resumeAfterTest","_resumeAfterBody","updateValue","window","chrome","framework","err","Promise","res","setTimeout","Helmet","src","Provider","props","initialize_media_player","auto_initialize","useContext","castCtx","isConnect","setIsConnect","initiliazeCast","useCallback","media_player","sessionRequest","SessionRequest","media","apiConfig","ApiConfig","initialize","handleConnection","rej","requestSession","Cast","setMedia","isMedia","setIsMedia","playMedia","autoplay","mediaInfo","MediaInfo","request","LoadRequest","loadMedia","addMedia","queueItem","QueueItem","queueAppendItem","play","pause","prev","queuePrev","next","queueNext","to","seconds","seek","SeekRequest","currentTime"],"mappings":"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"}