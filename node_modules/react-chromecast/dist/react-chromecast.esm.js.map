{"version":3,"file":"react-chromecast.esm.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/context/castContext.ts","../src/helpers/toWait.ts","../src/components/CastProvider.tsx","../src/hooks/useCast.ts","../src/hooks/useMedia.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { createContext } from \"react\";\r\n\r\nimport CastReceiver from \"../interfaces/CastReceiver\";\r\n\r\nconst castContext = createContext<{\r\n  castReceiver?: CastReceiver;\r\n  castSender?: any;\r\n  setSession?: (p: any) => void;\r\n  session?: any;\r\n}>({});\r\n\r\nexport default castContext;\r\n","const wait = (time: number) =>\r\n  new Promise(res => {\r\n    setTimeout(res, time);\r\n  });\r\n\r\nexport default wait;\r\n","import * as React from 'react';\r\n\r\nimport { Helmet } from 'react-helmet';\r\nimport castContext from '../context/castContext';\r\n\r\nimport CastReceiver from '../interfaces/CastReceiver';\r\n\r\nimport toWait from '../helpers/toWait';\r\n\r\nconst { useState, useEffect } = React;\r\n\r\n/**\r\n * CastProvider is a component to use arround every component you go use with `react-chromecast` hooks\r\n *\r\n * Ex:\r\n * ```jsx\r\n *  import CastProvider from 'react-chromecast'\r\n *  function App () {\r\n *    return (\r\n *      <CastProvider>\r\n *        {\r\n *          // your components using react-chromecast hooks goes here\r\n *        }\r\n *      </CastProvider>\r\n *    )\r\n *  }\r\n * ```\r\n */\r\nfunction CastProvider({ children }: { children: any }) {\r\n  const [cast, setCast] = useState<{\r\n    castReceiver?: CastReceiver;\r\n    castSender?: any;\r\n  }>({});\r\n  const [session, setSession] = useState<any>({});\r\n  useEffect(() => {\r\n    (async () => {\r\n      let toBreak = false;\r\n      let tries = 15;\r\n      let castReceiver: CastReceiver;\r\n      let castSender: any;\r\n      while (true) {\r\n        try {\r\n          // @ts-ignore\r\n          castReceiver = window.chrome.cast as CastReceiver;\r\n          // @ts-ignore\r\n          castSender = window.cast.framework as any;\r\n          toBreak = true;\r\n        } catch (err) {\r\n          tries--;\r\n          if (!tries) {\r\n            toBreak = true;\r\n          }\r\n        } finally {\r\n          if (toBreak) break;\r\n        }\r\n        await toWait(95);\r\n      }\r\n      // @ts-ignore\r\n      if (tries !== 0 && !!castReceiver) {\r\n        setCast({\r\n          castReceiver,\r\n          castSender,\r\n        });\r\n      } else {\r\n        throw new Error(\"Can't Load castReceiver and\\\\or castSender\");\r\n      }\r\n    })();\r\n  }, []);\r\n  return (\r\n    <>\r\n      <Helmet>\r\n        <script src=\"//www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1\" />\r\n        <script src=\"//www.gstatic.com/cast/sdk/libs/receiver/2.0.0/cast_receiver.js\" />\r\n      </Helmet>\r\n      <castContext.Provider\r\n        value={{\r\n          ...cast,\r\n          session,\r\n          setSession,\r\n        }}\r\n      >\r\n        {children}\r\n      </castContext.Provider>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default CastProvider;\r\n","import { useEffect, useContext, useCallback, useState } from \"react\";\r\n\r\nimport castCtx from \"../context/castContext\";\r\n\r\nimport CastReceiver from \"../interfaces/CastReceiver\";\r\n\r\ninterface Props {\r\n  /**\r\n   * @param initialize_media_player - is media_receiver id\r\n   *\r\n   * if you pass auto_initialize as true you should pass this\r\n   *\r\n   * you should pass media_receiver id or 'DEFAULT_MEDIA_RECEIVER_APP_ID' to use default media receiver\r\n   */\r\n  initialize_media_player?: string;\r\n  /**\r\n   * @param auto_initialize - you can use this to auto initialize cast media player when castReceiver was define\r\n   *\r\n   * you not need to pass nothing to this if you go initialize by yourself\r\n   */\r\n  auto_initialize?: boolean;\r\n}\r\n\r\ninterface Cast {\r\n  /**\r\n   * Function to initialize cast player before connect to chromecast\r\n   *\r\n   * This function should wait for castReceiver\r\n   *\r\n   * @param media_player - you should pass media_receiver id or 'DEFAULT_MEDIA_RECEIVER_APP_ID' to use default media receiver\r\n   *\r\n   * Example:\r\n   * ```jsx\r\n   *  const cast = useCast()\r\n   *  useEffect(() => {\r\n   *    if(cast.castReceiver){\r\n   *      cast.initializeCast('DEFAULT_MEDIA_RECEIVER_APP_ID')\r\n   *    }\r\n   *  }, [cast.castReceiver])\r\n   * ```\r\n   */\r\n  initializeCast?: (media_player: string) => void;\r\n  /**\r\n   * Function to connect and disconnect client to chromecast\r\n   */\r\n  handleConnection: () => Promise<any>;\r\n  /**\r\n   * castReceiver object, from cast_receiver google lib\r\n   */\r\n  castReceiver?: CastReceiver;\r\n  /**\r\n   * castSender object, from cast_sender google lib\r\n   */\r\n  castSender?: any;\r\n  /**\r\n   * this inidicate if client is connected with chromecast or not\r\n   */\r\n  isConnect: boolean;\r\n}\r\n\r\nfunction useCast(props?: Props) {\r\n  const { initialize_media_player, auto_initialize } = props || {};\r\n\r\n  const { castReceiver, castSender, setSession } = useContext(castCtx);\r\n  const [cast, setCast] = useState({});\r\n  const [isConnect, setIsConnect] = useState(false);\r\n  const initiliazeCast = useCallback(\r\n    (media_player: string) => {\r\n      if (!castReceiver) return;\r\n      const sessionRequest = new castReceiver.SessionRequest(\r\n        castReceiver.media[media_player]\r\n      );\r\n      const apiConfig = new castReceiver.ApiConfig(\r\n        // @ts-ignore\r\n        sessionRequest,\r\n        (e: any) => {\r\n          // console.log(\"ss listener\", e);\r\n          if (setSession) setSession(e);\r\n          setIsConnect(true);\r\n        },\r\n        (e: any) => {\r\n          // console.log(\"rc listener\", e);\r\n        }\r\n      );\r\n      castReceiver.initialize(\r\n        apiConfig,\r\n        (e: any) => {\r\n          // console.log(\"init success\", e);\r\n        },\r\n        (e: any) => {\r\n          // console.log(\"init error\", e);\r\n        }\r\n      );\r\n      setCast({\r\n        castReceiver,\r\n      });\r\n    },\r\n    [castReceiver, setSession]\r\n  );\r\n\r\n  const handleConnection = useCallback(\r\n    () =>\r\n      new Promise((res, rej) => {\r\n        if (castReceiver) {\r\n          // @ts-ignore\r\n          castReceiver.requestSession(\r\n            (e: any) => {\r\n              if (setSession) setSession(e);\r\n              setIsConnect(true);\r\n              res(e);\r\n            },\r\n            (e: any) => {\r\n              setIsConnect(false);\r\n              if (!isConnect) return rej(e);\r\n              return res(null);\r\n            }\r\n          );\r\n        }\r\n      }),\r\n    [castReceiver, setSession]\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (castReceiver) {\r\n      setCast({ castReceiver });\r\n      if (auto_initialize && !initialize_media_player)\r\n        throw new Error(\r\n          \"if you pass auto_initialize: true, you should pass initialize_media_player\"\r\n        );\r\n      else if (auto_initialize && initialize_media_player)\r\n        initiliazeCast(initialize_media_player);\r\n    }\r\n  }, [castReceiver, castSender]);\r\n\r\n  const Cast = { ...cast, handleConnection, isConnect } as Cast;\r\n\r\n  if (!auto_initialize) {\r\n    Cast[\"initializeCast\"] = initiliazeCast;\r\n  }\r\n\r\n  return Cast;\r\n}\r\n\r\nexport default useCast;\r\n","import { useCallback, useContext, useState, useEffect } from \"react\";\r\n\r\nimport castCtx from \"../context/castContext\";\r\n\r\ninterface Media {\r\n  /**\r\n   * @function playMedia - function to add an media url to chromecast to play, you should use this to first media before add more with the add function, and before use play function\r\n   * @param src - this should be an media url acessible by chromecast\r\n   * @param autoplay - this inidicate if media will play after defined, default is true\r\n   */\r\n  playMedia: (src: string, autoplay?: boolean) => Promise<any>;\r\n  /**\r\n   * @function addMedia - function to add an media url to chromecast queue\r\n   * @param src - this should be an media url acessible by chromecast\r\n   */\r\n  addMedia: (src: string) => Promise<any>;\r\n  /**\r\n   * @function play - function to play media in chromecast\r\n   */\r\n  play: () => Promise<any>;\r\n  /**\r\n   * @function pause - function to pause media in chromecast\r\n   */\r\n  pause: () => Promise<any>;\r\n  /**\r\n   * this inidicate if is a media connected to chromecast\r\n   */\r\n  isMedia: boolean;\r\n  /**\r\n   * @function next - function to jump to next video in chromecast queue\r\n   */\r\n  next: () => Promise<any>;\r\n  /**\r\n   * @function prev - function to jump to prev video in chromecast queue\r\n   */\r\n  prev: () => Promise<any>;\r\n  /**\r\n   * @function to - function to jump to the time passed in seconds in chromecast playing video\r\n   * @param seconds - time in seconds to jump to\r\n   */\r\n  to: (seconds: number) => Promise<any>;\r\n}\r\n\r\nfunction useMedia() {\r\n  const { session, castReceiver } = useContext(castCtx);\r\n  const [media, setMedia] = useState<any>(null);\r\n  const [isMedia, setIsMedia] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (!session && isMedia) setIsMedia(false);\r\n  }, [session, isMedia]);\r\n\r\n  const playMedia = useCallback(\r\n    (src: string, autoplay?: boolean) =>\r\n      new Promise((res, rej) => {\r\n        if (!castReceiver || !session)\r\n          return rej(new Error(\"An Error occurred\"));\r\n\r\n        // @ts-ignore\r\n        const mediaInfo = new castReceiver.media.MediaInfo(src);\r\n        // @ts-ignore\r\n        const request = new castReceiver.media.LoadRequest(mediaInfo);\r\n\r\n        request.autoplay = autoplay || true;\r\n        session.loadMedia(\r\n          request,\r\n          (media: any) => {\r\n            setMedia(media);\r\n            setIsMedia(true);\r\n            res(media);\r\n          },\r\n          (err: any) => rej(err)\r\n        );\r\n      }),\r\n    [castReceiver, session]\r\n  );\r\n\r\n  const addMedia = useCallback(\r\n    async (src: string) => {\r\n      if (!castReceiver && !media) return;\r\n      // @ts-ignore\r\n      const mediaInfo = new castReceiver.media.MediaInfo(src);\r\n      // @ts-ignore\r\n      const queueItem = new castReceiver.media.QueueItem(mediaInfo);\r\n      await media.queueAppendItem(queueItem);\r\n    },\r\n    [media, castReceiver]\r\n  );\r\n\r\n  const play = useCallback(async () => {\r\n    if (!media) return;\r\n    await media.play();\r\n  }, [media]);\r\n\r\n  const pause = useCallback(async () => {\r\n    if (!media) return;\r\n    await media.pause();\r\n  }, [media]);\r\n\r\n  const prev = useCallback(async () => {\r\n    if (!media) return;\r\n    await media.queuePrev();\r\n  }, [media]);\r\n\r\n  const next = useCallback(async () => {\r\n    if (!media) return;\r\n    await media.queueNext();\r\n  }, [media]);\r\n\r\n  const to = useCallback(\r\n    async (seconds: number) => {\r\n      if (!media && !castReceiver) return;\r\n\r\n      // @ts-ignore\r\n      const seek = new castReceiver.media.SeekRequest();\r\n\r\n      seek.currentTime = seconds;\r\n\r\n      await media.seek(seek);\r\n    },\r\n    [media, castReceiver]\r\n  );\r\n\r\n  return {\r\n    playMedia,\r\n    addMedia,\r\n    play,\r\n    pause,\r\n    isMedia,\r\n    next,\r\n    prev,\r\n    to,\r\n  } as Media;\r\n}\r\n\r\nexport default useMedia;\r\n"],"names":["castContext","createContext","wait","time","Promise","res","setTimeout","useState","React","useEffect","CastProvider","children","cast","setCast","session","setSession","tries","castReceiver","castSender","Error","toBreak","window","chrome","framework","err","toWait","Helmet","src","Provider","value","useCast","props","initialize_media_player","auto_initialize","useContext","castCtx","isConnect","setIsConnect","initiliazeCast","useCallback","media_player","sessionRequest","SessionRequest","media","apiConfig","ApiConfig","e","initialize","handleConnection","rej","requestSession","Cast","useMedia","setMedia","isMedia","setIsMedia","playMedia","autoplay","mediaInfo","MediaInfo","request","LoadRequest","loadMedia","addMedia","queueItem","QueueItem","queueAppendItem","play","pause","prev","queuePrev","next","queueNext","to","seconds","seek","SeekRequest","currentTime"],"mappings":"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"}