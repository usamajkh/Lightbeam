import { createContext, createElement, Fragment, useState as useState$1, useEffect as useEffect$1, useContext, useCallback } from 'react';
import { Helmet } from 'react-helmet';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

// A type of promise-like that resolves synchronously and supports only one observer
const _Pact = /*#__PURE__*/(function() {
	function _Pact() {}
	_Pact.prototype.then = function(onFulfilled, onRejected) {
		const result = new _Pact();
		const state = this.s;
		if (state) {
			const callback = state & 1 ? onFulfilled : onRejected;
			if (callback) {
				try {
					_settle(result, 1, callback(this.v));
				} catch (e) {
					_settle(result, 2, e);
				}
				return result;
			} else {
				return this;
			}
		}
		this.o = function(_this) {
			try {
				const value = _this.v;
				if (_this.s & 1) {
					_settle(result, 1, onFulfilled ? onFulfilled(value) : value);
				} else if (onRejected) {
					_settle(result, 1, onRejected(value));
				} else {
					_settle(result, 2, value);
				}
			} catch (e) {
				_settle(result, 2, e);
			}
		};
		return result;
	};
	return _Pact;
})();

// Settles a pact synchronously
function _settle(pact, state, value) {
	if (!pact.s) {
		if (value instanceof _Pact) {
			if (value.s) {
				if (state & 1) {
					state = value.s;
				}
				value = value.v;
			} else {
				value.o = _settle.bind(null, pact, state);
				return;
			}
		}
		if (value && value.then) {
			value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
			return;
		}
		pact.s = state;
		pact.v = value;
		const observer = pact.o;
		if (observer) {
			observer(pact);
		}
	}
}

function _isSettledPact(thenable) {
	return thenable instanceof _Pact && thenable.s & 1;
}

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously implement a generic for loop
function _for(test, update, body) {
	var stage;
	for (;;) {
		var shouldContinue = test();
		if (_isSettledPact(shouldContinue)) {
			shouldContinue = shouldContinue.v;
		}
		if (!shouldContinue) {
			return result;
		}
		if (shouldContinue.then) {
			stage = 0;
			break;
		}
		var result = body();
		if (result && result.then) {
			if (_isSettledPact(result)) {
				result = result.s;
			} else {
				stage = 1;
				break;
			}
		}
		if (update) {
			var updateValue = update();
			if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
				stage = 2;
				break;
			}
		}
	}
	var pact = new _Pact();
	var reject = _settle.bind(null, pact, 2);
	(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);
	return pact;
	function _resumeAfterBody(value) {
		result = value;
		do {
			if (update) {
				updateValue = update();
				if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
					updateValue.then(_resumeAfterUpdate).then(void 0, reject);
					return;
				}
			}
			shouldContinue = test();
			if (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {
				_settle(pact, 1, result);
				return;
			}
			if (shouldContinue.then) {
				shouldContinue.then(_resumeAfterTest).then(void 0, reject);
				return;
			}
			result = body();
			if (_isSettledPact(result)) {
				result = result.v;
			}
		} while (!result || !result.then);
		result.then(_resumeAfterBody).then(void 0, reject);
	}
	function _resumeAfterTest(shouldContinue) {
		if (shouldContinue) {
			result = body();
			if (result && result.then) {
				result.then(_resumeAfterBody).then(void 0, reject);
			} else {
				_resumeAfterBody(result);
			}
		} else {
			_settle(pact, 1, result);
		}
	}
	function _resumeAfterUpdate() {
		if (shouldContinue = test()) {
			if (shouldContinue.then) {
				shouldContinue.then(_resumeAfterTest).then(void 0, reject);
			} else {
				_resumeAfterTest(shouldContinue);
			}
		} else {
			_settle(pact, 1, result);
		}
	}
}

var castContext = /*#__PURE__*/createContext({});

var wait = function wait(time) {
  return new Promise(function (res) {
    setTimeout(res, time);
  });
};

var useState = useState$1,
    useEffect = useEffect$1;
/**
 * CastProvider is a component to use arround every component you go use with `react-chromecast` hooks
 *
 * Ex:
 * ```jsx
 *  import CastProvider from 'react-chromecast'
 *  function App () {
 *    return (
 *      <CastProvider>
 *        {
 *          // your components using react-chromecast hooks goes here
 *        }
 *      </CastProvider>
 *    )
 *  }
 * ```
 */

function CastProvider(_ref) {
  var children = _ref.children;

  var _useState = useState({}),
      cast = _useState[0],
      setCast = _useState[1];

  var _useState2 = useState({}),
      session = _useState2[0],
      setSession = _useState2[1];

  useEffect(function () {
    (function () {
      try {
        var _temp3 = function _temp3() {
          if (tries !== 0 && !!castReceiver) {
            setCast({
              castReceiver: castReceiver,
              castSender: castSender
            });
          } else {
            throw new Error("Can't Load castReceiver and\\or castSender");
          }
        };

        var _interrupt2 = false;
        var toBreak = false;
        var tries = 15;
        var castReceiver;
        var castSender;

        var _temp4 = _for(function () {
          return !_interrupt2;
        }, void 0, function () {
          try {
            // @ts-ignore
            castReceiver = window.chrome.cast; // @ts-ignore

            castSender = window.cast.framework;
            toBreak = true;
          } catch (err) {
            tries--;

            if (!tries) {
              toBreak = true;
            }
          } finally {
            if (toBreak) {
              _interrupt2 = true;
              return;
            }
          }

          return Promise.resolve(wait(95)).then(function () {});
        });

        return _temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4); // @ts-ignore
      } catch (e) {
        Promise.reject(e);
      }
    })();
  }, []);
  return createElement(Fragment, null, createElement(Helmet, null, createElement("script", {
    src: "//www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1"
  }), createElement("script", {
    src: "//www.gstatic.com/cast/sdk/libs/receiver/2.0.0/cast_receiver.js"
  })), createElement(castContext.Provider, {
    value: _extends({}, cast, {
      session: session,
      setSession: setSession
    })
  }, children));
}

function useCast(props) {
  var _ref = props || {},
      initialize_media_player = _ref.initialize_media_player,
      auto_initialize = _ref.auto_initialize;

  var _useContext = useContext(castContext),
      castReceiver = _useContext.castReceiver,
      castSender = _useContext.castSender,
      setSession = _useContext.setSession;

  var _useState = useState$1({}),
      cast = _useState[0],
      setCast = _useState[1];

  var _useState2 = useState$1(false),
      isConnect = _useState2[0],
      setIsConnect = _useState2[1];

  var initiliazeCast = useCallback(function (media_player) {
    if (!castReceiver) return;
    var sessionRequest = new castReceiver.SessionRequest(castReceiver.media[media_player]);
    var apiConfig = new castReceiver.ApiConfig( // @ts-ignore
    sessionRequest, function (e) {
      // console.log("ss listener", e);
      if (setSession) setSession(e);
      setIsConnect(true);
    }, function (e) {// console.log("rc listener", e);
    });
    castReceiver.initialize(apiConfig, function (e) {// console.log("init success", e);
    }, function (e) {// console.log("init error", e);
    });
    setCast({
      castReceiver: castReceiver
    });
  }, [castReceiver, setSession]);
  var handleConnection = useCallback(function () {
    return new Promise(function (res, rej) {
      if (castReceiver) {
        // @ts-ignore
        castReceiver.requestSession(function (e) {
          if (setSession) setSession(e);
          setIsConnect(true);
          res(e);
        }, function (e) {
          setIsConnect(false);
          if (!isConnect) return rej(e);
          return res(null);
        });
      }
    });
  }, [castReceiver, setSession]);
  useEffect$1(function () {
    if (castReceiver) {
      setCast({
        castReceiver: castReceiver
      });
      if (auto_initialize && !initialize_media_player) throw new Error("if you pass auto_initialize: true, you should pass initialize_media_player");else if (auto_initialize && initialize_media_player) initiliazeCast(initialize_media_player);
    }
  }, [castReceiver, castSender]);

  var Cast = _extends({}, cast, {
    handleConnection: handleConnection,
    isConnect: isConnect
  });

  if (!auto_initialize) {
    Cast["initializeCast"] = initiliazeCast;
  }

  return Cast;
}

function useMedia() {
  var _useContext = useContext(castContext),
      session = _useContext.session,
      castReceiver = _useContext.castReceiver;

  var _useState = useState$1(null),
      media = _useState[0],
      setMedia = _useState[1];

  var _useState2 = useState$1(false),
      isMedia = _useState2[0],
      setIsMedia = _useState2[1];

  useEffect$1(function () {
    if (!session && isMedia) setIsMedia(false);
  }, [session, isMedia]);
  var playMedia = useCallback(function (src, autoplay) {
    return new Promise(function (res, rej) {
      if (!castReceiver || !session) return rej(new Error("An Error occurred")); // @ts-ignore

      var mediaInfo = new castReceiver.media.MediaInfo(src); // @ts-ignore

      var request = new castReceiver.media.LoadRequest(mediaInfo);
      request.autoplay = autoplay || true;
      session.loadMedia(request, function (media) {
        setMedia(media);
        setIsMedia(true);
        res(media);
      }, function (err) {
        return rej(err);
      });
    });
  }, [castReceiver, session]);
  var addMedia = useCallback(function (src) {
    try {
      if (!castReceiver && !media) return Promise.resolve(); // @ts-ignore

      var mediaInfo = new castReceiver.media.MediaInfo(src); // @ts-ignore

      var queueItem = new castReceiver.media.QueueItem(mediaInfo);
      return Promise.resolve(media.queueAppendItem(queueItem)).then(function () {});
    } catch (e) {
      return Promise.reject(e);
    }
  }, [media, castReceiver]);
  var play = useCallback(function () {
    try {
      if (!media) return Promise.resolve();
      return Promise.resolve(media.play()).then(function () {});
    } catch (e) {
      return Promise.reject(e);
    }
  }, [media]);
  var pause = useCallback(function () {
    try {
      if (!media) return Promise.resolve();
      return Promise.resolve(media.pause()).then(function () {});
    } catch (e) {
      return Promise.reject(e);
    }
  }, [media]);
  var prev = useCallback(function () {
    try {
      if (!media) return Promise.resolve();
      return Promise.resolve(media.queuePrev()).then(function () {});
    } catch (e) {
      return Promise.reject(e);
    }
  }, [media]);
  var next = useCallback(function () {
    try {
      if (!media) return Promise.resolve();
      return Promise.resolve(media.queueNext()).then(function () {});
    } catch (e) {
      return Promise.reject(e);
    }
  }, [media]);
  var to = useCallback(function (seconds) {
    try {
      if (!media && !castReceiver) return Promise.resolve(); // @ts-ignore

      var seek = new castReceiver.media.SeekRequest();
      seek.currentTime = seconds;
      return Promise.resolve(media.seek(seek)).then(function () {});
    } catch (e) {
      return Promise.reject(e);
    }
  }, [media, castReceiver]);
  return {
    playMedia: playMedia,
    addMedia: addMedia,
    play: play,
    pause: pause,
    isMedia: isMedia,
    next: next,
    prev: prev,
    to: to
  };
}

export default CastProvider;
export { useCast, useMedia };
//# sourceMappingURL=react-chromecast.esm.js.map
