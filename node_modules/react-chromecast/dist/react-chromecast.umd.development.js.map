{"version":3,"file":"react-chromecast.umd.development.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/context/castContext.ts","../src/helpers/toWait.ts","../src/components/CastProvider.tsx","../src/hooks/useCast.ts","../src/hooks/useMedia.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { createContext } from \"react\";\r\n\r\nimport CastReceiver from \"../interfaces/CastReceiver\";\r\n\r\nconst castContext = createContext<{\r\n  castReceiver?: CastReceiver;\r\n  castSender?: any;\r\n  setSession?: (p: any) => void;\r\n  session?: any;\r\n}>({});\r\n\r\nexport default castContext;\r\n","const wait = (time: number) =>\r\n  new Promise(res => {\r\n    setTimeout(res, time);\r\n  });\r\n\r\nexport default wait;\r\n","import * as React from 'react';\r\n\r\nimport { Helmet } from 'react-helmet';\r\nimport castContext from '../context/castContext';\r\n\r\nimport CastReceiver from '../interfaces/CastReceiver';\r\n\r\nimport toWait from '../helpers/toWait';\r\n\r\nconst { useState, useEffect } = React;\r\n\r\n/**\r\n * CastProvider is a component to use arround every component you go use with `react-chromecast` hooks\r\n *\r\n * Ex:\r\n * ```jsx\r\n *  import CastProvider from 'react-chromecast'\r\n *  function App () {\r\n *    return (\r\n *      <CastProvider>\r\n *        {\r\n *          // your components using react-chromecast hooks goes here\r\n *        }\r\n *      </CastProvider>\r\n *    )\r\n *  }\r\n * ```\r\n */\r\nfunction CastProvider({ children }: { children: any }) {\r\n  const [cast, setCast] = useState<{\r\n    castReceiver?: CastReceiver;\r\n    castSender?: any;\r\n  }>({});\r\n  const [session, setSession] = useState<any>({});\r\n  useEffect(() => {\r\n    (async () => {\r\n      let toBreak = false;\r\n      let tries = 15;\r\n      let castReceiver: CastReceiver;\r\n      let castSender: any;\r\n      while (true) {\r\n        try {\r\n          // @ts-ignore\r\n          castReceiver = window.chrome.cast as CastReceiver;\r\n          // @ts-ignore\r\n          castSender = window.cast.framework as any;\r\n          toBreak = true;\r\n        } catch (err) {\r\n          tries--;\r\n          if (!tries) {\r\n            toBreak = true;\r\n          }\r\n        } finally {\r\n          if (toBreak) break;\r\n        }\r\n        await toWait(95);\r\n      }\r\n      // @ts-ignore\r\n      if (tries !== 0 && !!castReceiver) {\r\n        setCast({\r\n          castReceiver,\r\n          castSender,\r\n        });\r\n      } else {\r\n        throw new Error(\"Can't Load castReceiver and\\\\or castSender\");\r\n      }\r\n    })();\r\n  }, []);\r\n  return (\r\n    <>\r\n      <Helmet>\r\n        <script src=\"//www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1\" />\r\n        <script src=\"//www.gstatic.com/cast/sdk/libs/receiver/2.0.0/cast_receiver.js\" />\r\n      </Helmet>\r\n      <castContext.Provider\r\n        value={{\r\n          ...cast,\r\n          session,\r\n          setSession,\r\n        }}\r\n      >\r\n        {children}\r\n      </castContext.Provider>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default CastProvider;\r\n","import { useEffect, useContext, useCallback, useState } from \"react\";\r\n\r\nimport castCtx from \"../context/castContext\";\r\n\r\nimport CastReceiver from \"../interfaces/CastReceiver\";\r\n\r\ninterface Props {\r\n  /**\r\n   * @param initialize_media_player - is media_receiver id\r\n   *\r\n   * if you pass auto_initialize as true you should pass this\r\n   *\r\n   * you should pass media_receiver id or 'DEFAULT_MEDIA_RECEIVER_APP_ID' to use default media receiver\r\n   */\r\n  initialize_media_player?: string;\r\n  /**\r\n   * @param auto_initialize - you can use this to auto initialize cast media player when castReceiver was define\r\n   *\r\n   * you not need to pass nothing to this if you go initialize by yourself\r\n   */\r\n  auto_initialize?: boolean;\r\n}\r\n\r\ninterface Cast {\r\n  /**\r\n   * Function to initialize cast player before connect to chromecast\r\n   *\r\n   * This function should wait for castReceiver\r\n   *\r\n   * @param media_player - you should pass media_receiver id or 'DEFAULT_MEDIA_RECEIVER_APP_ID' to use default media receiver\r\n   *\r\n   * Example:\r\n   * ```jsx\r\n   *  const cast = useCast()\r\n   *  useEffect(() => {\r\n   *    if(cast.castReceiver){\r\n   *      cast.initializeCast('DEFAULT_MEDIA_RECEIVER_APP_ID')\r\n   *    }\r\n   *  }, [cast.castReceiver])\r\n   * ```\r\n   */\r\n  initializeCast?: (media_player: string) => void;\r\n  /**\r\n   * Function to connect and disconnect client to chromecast\r\n   */\r\n  handleConnection: () => Promise<any>;\r\n  /**\r\n   * castReceiver object, from cast_receiver google lib\r\n   */\r\n  castReceiver?: CastReceiver;\r\n  /**\r\n   * castSender object, from cast_sender google lib\r\n   */\r\n  castSender?: any;\r\n  /**\r\n   * this inidicate if client is connected with chromecast or not\r\n   */\r\n  isConnect: boolean;\r\n}\r\n\r\nfunction useCast(props?: Props) {\r\n  const { initialize_media_player, auto_initialize } = props || {};\r\n\r\n  const { castReceiver, castSender, setSession } = useContext(castCtx);\r\n  const [cast, setCast] = useState({});\r\n  const [isConnect, setIsConnect] = useState(false);\r\n  const initiliazeCast = useCallback(\r\n    (media_player: string) => {\r\n      if (!castReceiver) return;\r\n      const sessionRequest = new castReceiver.SessionRequest(\r\n        castReceiver.media[media_player]\r\n      );\r\n      const apiConfig = new castReceiver.ApiConfig(\r\n        // @ts-ignore\r\n        sessionRequest,\r\n        (e: any) => {\r\n          // console.log(\"ss listener\", e);\r\n          if (setSession) setSession(e);\r\n          setIsConnect(true);\r\n        },\r\n        (e: any) => {\r\n          // console.log(\"rc listener\", e);\r\n        }\r\n      );\r\n      castReceiver.initialize(\r\n        apiConfig,\r\n        (e: any) => {\r\n          // console.log(\"init success\", e);\r\n        },\r\n        (e: any) => {\r\n          // console.log(\"init error\", e);\r\n        }\r\n      );\r\n      setCast({\r\n        castReceiver,\r\n      });\r\n    },\r\n    [castReceiver, setSession]\r\n  );\r\n\r\n  const handleConnection = useCallback(\r\n    () =>\r\n      new Promise((res, rej) => {\r\n        if (castReceiver) {\r\n          // @ts-ignore\r\n          castReceiver.requestSession(\r\n            (e: any) => {\r\n              if (setSession) setSession(e);\r\n              setIsConnect(true);\r\n              res(e);\r\n            },\r\n            (e: any) => {\r\n              setIsConnect(false);\r\n              if (!isConnect) return rej(e);\r\n              return res(null);\r\n            }\r\n          );\r\n        }\r\n      }),\r\n    [castReceiver, setSession]\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (castReceiver) {\r\n      setCast({ castReceiver });\r\n      if (auto_initialize && !initialize_media_player)\r\n        throw new Error(\r\n          \"if you pass auto_initialize: true, you should pass initialize_media_player\"\r\n        );\r\n      else if (auto_initialize && initialize_media_player)\r\n        initiliazeCast(initialize_media_player);\r\n    }\r\n  }, [castReceiver, castSender]);\r\n\r\n  const Cast = { ...cast, handleConnection, isConnect } as Cast;\r\n\r\n  if (!auto_initialize) {\r\n    Cast[\"initializeCast\"] = initiliazeCast;\r\n  }\r\n\r\n  return Cast;\r\n}\r\n\r\nexport default useCast;\r\n","import { useCallback, useContext, useState, useEffect } from \"react\";\r\n\r\nimport castCtx from \"../context/castContext\";\r\n\r\ninterface Media {\r\n  /**\r\n   * @function playMedia - function to add an media url to chromecast to play, you should use this to first media before add more with the add function, and before use play function\r\n   * @param src - this should be an media url acessible by chromecast\r\n   * @param autoplay - this inidicate if media will play after defined, default is true\r\n   */\r\n  playMedia: (src: string, autoplay?: boolean) => Promise<any>;\r\n  /**\r\n   * @function addMedia - function to add an media url to chromecast queue\r\n   * @param src - this should be an media url acessible by chromecast\r\n   */\r\n  addMedia: (src: string) => Promise<any>;\r\n  /**\r\n   * @function play - function to play media in chromecast\r\n   */\r\n  play: () => Promise<any>;\r\n  /**\r\n   * @function pause - function to pause media in chromecast\r\n   */\r\n  pause: () => Promise<any>;\r\n  /**\r\n   * this inidicate if is a media connected to chromecast\r\n   */\r\n  isMedia: boolean;\r\n  /**\r\n   * @function next - function to jump to next video in chromecast queue\r\n   */\r\n  next: () => Promise<any>;\r\n  /**\r\n   * @function prev - function to jump to prev video in chromecast queue\r\n   */\r\n  prev: () => Promise<any>;\r\n  /**\r\n   * @function to - function to jump to the time passed in seconds in chromecast playing video\r\n   * @param seconds - time in seconds to jump to\r\n   */\r\n  to: (seconds: number) => Promise<any>;\r\n}\r\n\r\nfunction useMedia() {\r\n  const { session, castReceiver } = useContext(castCtx);\r\n  const [media, setMedia] = useState<any>(null);\r\n  const [isMedia, setIsMedia] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (!session && isMedia) setIsMedia(false);\r\n  }, [session, isMedia]);\r\n\r\n  const playMedia = useCallback(\r\n    (src: string, autoplay?: boolean) =>\r\n      new Promise((res, rej) => {\r\n        if (!castReceiver || !session)\r\n          return rej(new Error(\"An Error occurred\"));\r\n\r\n        // @ts-ignore\r\n        const mediaInfo = new castReceiver.media.MediaInfo(src);\r\n        // @ts-ignore\r\n        const request = new castReceiver.media.LoadRequest(mediaInfo);\r\n\r\n        request.autoplay = autoplay || true;\r\n        session.loadMedia(\r\n          request,\r\n          (media: any) => {\r\n            setMedia(media);\r\n            setIsMedia(true);\r\n            res(media);\r\n          },\r\n          (err: any) => rej(err)\r\n        );\r\n      }),\r\n    [castReceiver, session]\r\n  );\r\n\r\n  const addMedia = useCallback(\r\n    async (src: string) => {\r\n      if (!castReceiver && !media) return;\r\n      // @ts-ignore\r\n      const mediaInfo = new castReceiver.media.MediaInfo(src);\r\n      // @ts-ignore\r\n      const queueItem = new castReceiver.media.QueueItem(mediaInfo);\r\n      await media.queueAppendItem(queueItem);\r\n    },\r\n    [media, castReceiver]\r\n  );\r\n\r\n  const play = useCallback(async () => {\r\n    if (!media) return;\r\n    await media.play();\r\n  }, [media]);\r\n\r\n  const pause = useCallback(async () => {\r\n    if (!media) return;\r\n    await media.pause();\r\n  }, [media]);\r\n\r\n  const prev = useCallback(async () => {\r\n    if (!media) return;\r\n    await media.queuePrev();\r\n  }, [media]);\r\n\r\n  const next = useCallback(async () => {\r\n    if (!media) return;\r\n    await media.queueNext();\r\n  }, [media]);\r\n\r\n  const to = useCallback(\r\n    async (seconds: number) => {\r\n      if (!media && !castReceiver) return;\r\n\r\n      // @ts-ignore\r\n      const seek = new castReceiver.media.SeekRequest();\r\n\r\n      seek.currentTime = seconds;\r\n\r\n      await media.seek(seek);\r\n    },\r\n    [media, castReceiver]\r\n  );\r\n\r\n  return {\r\n    playMedia,\r\n    addMedia,\r\n    play,\r\n    pause,\r\n    isMedia,\r\n    next,\r\n    prev,\r\n    to,\r\n  } as Media;\r\n}\r\n\r\nexport default useMedia;\r\n"],"names":["castContext","createContext","wait","time","Promise","res","setTimeout","useState","React","useEffect","CastProvider","children","cast","setCast","session","setSession","tries","castReceiver","castSender","Error","toBreak","window","chrome","framework","err","toWait","Helmet","src","Provider","value","useCast","props","initialize_media_player","auto_initialize","useContext","castCtx","isConnect","setIsConnect","initiliazeCast","useCallback","media_player","sessionRequest","SessionRequest","media","apiConfig","ApiConfig","e","initialize","handleConnection","rej","requestSession","Cast","useMedia","setMedia","isMedia","setIsMedia","playMedia","autoplay","mediaInfo","MediaInfo","request","LoadRequest","loadMedia","addMedia","queueItem","QueueItem","queueAppendItem","play","pause","prev","queuePrev","next","queueNext","to","seconds","seek","SeekRequest","currentTime"],"mappings":"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"}