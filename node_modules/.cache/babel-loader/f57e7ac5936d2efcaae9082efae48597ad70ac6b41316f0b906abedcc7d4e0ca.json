{"ast":null,"code":"import { createContext, createElement, Fragment, useState as useState$1, useEffect as useEffect$1, useContext, useCallback } from 'react';\nimport { Helmet } from 'react-helmet';\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n// A type of promise-like that resolves synchronously and supports only one observer\nconst _Pact = /*#__PURE__*/function () {\n  function _Pact() {}\n  _Pact.prototype.then = function (onFulfilled, onRejected) {\n    const result = new _Pact();\n    const state = this.s;\n    if (state) {\n      const callback = state & 1 ? onFulfilled : onRejected;\n      if (callback) {\n        try {\n          _settle(result, 1, callback(this.v));\n        } catch (e) {\n          _settle(result, 2, e);\n        }\n        return result;\n      } else {\n        return this;\n      }\n    }\n    this.o = function (_this) {\n      try {\n        const value = _this.v;\n        if (_this.s & 1) {\n          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n        } else if (onRejected) {\n          _settle(result, 1, onRejected(value));\n        } else {\n          _settle(result, 2, value);\n        }\n      } catch (e) {\n        _settle(result, 2, e);\n      }\n    };\n    return result;\n  };\n  return _Pact;\n}();\n\n// Settles a pact synchronously\nfunction _settle(pact, state, value) {\n  if (!pact.s) {\n    if (value instanceof _Pact) {\n      if (value.s) {\n        if (state & 1) {\n          state = value.s;\n        }\n        value = value.v;\n      } else {\n        value.o = _settle.bind(null, pact, state);\n        return;\n      }\n    }\n    if (value && value.then) {\n      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n      return;\n    }\n    pact.s = state;\n    pact.v = value;\n    const observer = pact.o;\n    if (observer) {\n      observer(pact);\n    }\n  }\n}\nfunction _isSettledPact(thenable) {\n  return thenable instanceof _Pact && thenable.s & 1;\n}\nconst _iteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\")) : \"@@iterator\";\nconst _asyncIteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\")) : \"@@asyncIterator\";\n\n// Asynchronously implement a generic for loop\nfunction _for(test, update, body) {\n  var stage;\n  for (;;) {\n    var shouldContinue = test();\n    if (_isSettledPact(shouldContinue)) {\n      shouldContinue = shouldContinue.v;\n    }\n    if (!shouldContinue) {\n      return result;\n    }\n    if (shouldContinue.then) {\n      stage = 0;\n      break;\n    }\n    var result = body();\n    if (result && result.then) {\n      if (_isSettledPact(result)) {\n        result = result.s;\n      } else {\n        stage = 1;\n        break;\n      }\n    }\n    if (update) {\n      var updateValue = update();\n      if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n        stage = 2;\n        break;\n      }\n    }\n  }\n  var pact = new _Pact();\n  var reject = _settle.bind(null, pact, 2);\n  (stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n  return pact;\n  function _resumeAfterBody(value) {\n    result = value;\n    do {\n      if (update) {\n        updateValue = update();\n        if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n          updateValue.then(_resumeAfterUpdate).then(void 0, reject);\n          return;\n        }\n      }\n      shouldContinue = test();\n      if (!shouldContinue || _isSettledPact(shouldContinue) && !shouldContinue.v) {\n        _settle(pact, 1, result);\n        return;\n      }\n      if (shouldContinue.then) {\n        shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n        return;\n      }\n      result = body();\n      if (_isSettledPact(result)) {\n        result = result.v;\n      }\n    } while (!result || !result.then);\n    result.then(_resumeAfterBody).then(void 0, reject);\n  }\n  function _resumeAfterTest(shouldContinue) {\n    if (shouldContinue) {\n      result = body();\n      if (result && result.then) {\n        result.then(_resumeAfterBody).then(void 0, reject);\n      } else {\n        _resumeAfterBody(result);\n      }\n    } else {\n      _settle(pact, 1, result);\n    }\n  }\n  function _resumeAfterUpdate() {\n    if (shouldContinue = test()) {\n      if (shouldContinue.then) {\n        shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n      } else {\n        _resumeAfterTest(shouldContinue);\n      }\n    } else {\n      _settle(pact, 1, result);\n    }\n  }\n}\nvar castContext = /*#__PURE__*/createContext({});\nvar wait = function wait(time) {\n  return new Promise(function (res) {\n    setTimeout(res, time);\n  });\n};\nvar useState = useState$1,\n  useEffect = useEffect$1;\n/**\r\n * CastProvider is a component to use arround every component you go use with `react-chromecast` hooks\r\n *\r\n * Ex:\r\n * ```jsx\r\n *  import CastProvider from 'react-chromecast'\r\n *  function App () {\r\n *    return (\r\n *      <CastProvider>\r\n *        {\r\n *          // your components using react-chromecast hooks goes here\r\n *        }\r\n *      </CastProvider>\r\n *    )\r\n *  }\r\n * ```\r\n */\n\nfunction CastProvider(_ref) {\n  var children = _ref.children;\n  var _useState = useState({}),\n    cast = _useState[0],\n    setCast = _useState[1];\n  var _useState2 = useState({}),\n    session = _useState2[0],\n    setSession = _useState2[1];\n  useEffect(function () {\n    (function () {\n      try {\n        var _temp3 = function _temp3() {\n          if (tries !== 0 && !!castReceiver) {\n            setCast({\n              castReceiver: castReceiver,\n              castSender: castSender\n            });\n          } else {\n            throw new Error(\"Can't Load castReceiver and\\\\or castSender\");\n          }\n        };\n        var _interrupt2 = false;\n        var toBreak = false;\n        var tries = 15;\n        var castReceiver;\n        var castSender;\n        var _temp4 = _for(function () {\n          return !_interrupt2;\n        }, void 0, function () {\n          try {\n            // @ts-ignore\n            castReceiver = window.chrome.cast; // @ts-ignore\n\n            castSender = window.cast.framework;\n            toBreak = true;\n          } catch (err) {\n            tries--;\n            if (!tries) {\n              toBreak = true;\n            }\n          } finally {\n            if (toBreak) {\n              _interrupt2 = true;\n              return;\n            }\n          }\n          return Promise.resolve(wait(95)).then(function () {});\n        });\n        return _temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4); // @ts-ignore\n      } catch (e) {\n        Promise.reject(e);\n      }\n    })();\n  }, []);\n  return createElement(Fragment, null, createElement(Helmet, null, createElement(\"script\", {\n    src: \"//www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1\"\n  }), createElement(\"script\", {\n    src: \"//www.gstatic.com/cast/sdk/libs/receiver/2.0.0/cast_receiver.js\"\n  })), createElement(castContext.Provider, {\n    value: _extends({}, cast, {\n      session: session,\n      setSession: setSession\n    })\n  }, children));\n}\nfunction useCast(props) {\n  var _ref = props || {},\n    initialize_media_player = _ref.initialize_media_player,\n    auto_initialize = _ref.auto_initialize;\n  var _useContext = useContext(castContext),\n    castReceiver = _useContext.castReceiver,\n    castSender = _useContext.castSender,\n    setSession = _useContext.setSession;\n  var _useState = useState$1({}),\n    cast = _useState[0],\n    setCast = _useState[1];\n  var _useState2 = useState$1(false),\n    isConnect = _useState2[0],\n    setIsConnect = _useState2[1];\n  var initiliazeCast = useCallback(function (media_player) {\n    if (!castReceiver) return;\n    var sessionRequest = new castReceiver.SessionRequest(castReceiver.media[media_player]);\n    var apiConfig = new castReceiver.ApiConfig(\n    // @ts-ignore\n    sessionRequest, function (e) {\n      // console.log(\"ss listener\", e);\n      if (setSession) setSession(e);\n      setIsConnect(true);\n    }, function (e) {// console.log(\"rc listener\", e);\n    });\n    castReceiver.initialize(apiConfig, function (e) {// console.log(\"init success\", e);\n    }, function (e) {// console.log(\"init error\", e);\n    });\n    setCast({\n      castReceiver: castReceiver\n    });\n  }, [castReceiver, setSession]);\n  var handleConnection = useCallback(function () {\n    return new Promise(function (res, rej) {\n      if (castReceiver) {\n        // @ts-ignore\n        castReceiver.requestSession(function (e) {\n          if (setSession) setSession(e);\n          setIsConnect(true);\n          res(e);\n        }, function (e) {\n          setIsConnect(false);\n          if (!isConnect) return rej(e);\n          return res(null);\n        });\n      }\n    });\n  }, [castReceiver, setSession]);\n  useEffect$1(function () {\n    if (castReceiver) {\n      setCast({\n        castReceiver: castReceiver\n      });\n      if (auto_initialize && !initialize_media_player) throw new Error(\"if you pass auto_initialize: true, you should pass initialize_media_player\");else if (auto_initialize && initialize_media_player) initiliazeCast(initialize_media_player);\n    }\n  }, [castReceiver, castSender]);\n  var Cast = _extends({}, cast, {\n    handleConnection: handleConnection,\n    isConnect: isConnect\n  });\n  if (!auto_initialize) {\n    Cast[\"initializeCast\"] = initiliazeCast;\n  }\n  return Cast;\n}\nfunction useMedia() {\n  var _useContext = useContext(castContext),\n    session = _useContext.session,\n    castReceiver = _useContext.castReceiver;\n  var _useState = useState$1(null),\n    media = _useState[0],\n    setMedia = _useState[1];\n  var _useState2 = useState$1(false),\n    isMedia = _useState2[0],\n    setIsMedia = _useState2[1];\n  useEffect$1(function () {\n    if (!session && isMedia) setIsMedia(false);\n  }, [session, isMedia]);\n  var playMedia = useCallback(function (src, autoplay) {\n    return new Promise(function (res, rej) {\n      if (!castReceiver || !session) return rej(new Error(\"An Error occurred\")); // @ts-ignore\n\n      var mediaInfo = new castReceiver.media.MediaInfo(src); // @ts-ignore\n\n      var request = new castReceiver.media.LoadRequest(mediaInfo);\n      request.autoplay = autoplay || true;\n      session.loadMedia(request, function (media) {\n        setMedia(media);\n        setIsMedia(true);\n        res(media);\n      }, function (err) {\n        return rej(err);\n      });\n    });\n  }, [castReceiver, session]);\n  var addMedia = useCallback(function (src) {\n    try {\n      if (!castReceiver && !media) return Promise.resolve(); // @ts-ignore\n\n      var mediaInfo = new castReceiver.media.MediaInfo(src); // @ts-ignore\n\n      var queueItem = new castReceiver.media.QueueItem(mediaInfo);\n      return Promise.resolve(media.queueAppendItem(queueItem)).then(function () {});\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, [media, castReceiver]);\n  var play = useCallback(function () {\n    try {\n      if (!media) return Promise.resolve();\n      return Promise.resolve(media.play()).then(function () {});\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, [media]);\n  var pause = useCallback(function () {\n    try {\n      if (!media) return Promise.resolve();\n      return Promise.resolve(media.pause()).then(function () {});\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, [media]);\n  var prev = useCallback(function () {\n    try {\n      if (!media) return Promise.resolve();\n      return Promise.resolve(media.queuePrev()).then(function () {});\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, [media]);\n  var next = useCallback(function () {\n    try {\n      if (!media) return Promise.resolve();\n      return Promise.resolve(media.queueNext()).then(function () {});\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, [media]);\n  var to = useCallback(function (seconds) {\n    try {\n      if (!media && !castReceiver) return Promise.resolve(); // @ts-ignore\n\n      var seek = new castReceiver.media.SeekRequest();\n      seek.currentTime = seconds;\n      return Promise.resolve(media.seek(seek)).then(function () {});\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, [media, castReceiver]);\n  return {\n    playMedia: playMedia,\n    addMedia: addMedia,\n    play: play,\n    pause: pause,\n    isMedia: isMedia,\n    next: next,\n    prev: prev,\n    to: to\n  };\n}\nexport default CastProvider;\nexport { useCast, useMedia };","map":{"version":3,"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_isSettledPact","thenable","_iteratorSymbol","Symbol","iterator","_asyncIteratorSymbol","asyncIterator","_for","test","update","body","stage","shouldContinue","updateValue","reject","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","castContext","createContext","wait","time","Promise","res","setTimeout","useState","useState$1","useEffect","useEffect$1","CastProvider","_ref","children","cast","_useState","setCast","session","_useState2","setSession","tries","castReceiver","castSender","Error","toBreak","window","chrome","framework","err","_interrupt2","resolve","createElement","Fragment","Helmet","src","Provider","_extends","useCast","props","initialize_media_player","auto_initialize","useContext","_useContext","isConnect","setIsConnect","initiliazeCast","useCallback","media_player","sessionRequest","SessionRequest","media","apiConfig","ApiConfig","initialize","handleConnection","rej","requestSession","Cast","useMedia","setMedia","isMedia","setIsMedia","playMedia","autoplay","mediaInfo","MediaInfo","request","LoadRequest","loadMedia","addMedia","queueItem","QueueItem","queueAppendItem","play","pause","prev","queuePrev","next","queueNext","to","seconds","seek","SeekRequest","currentTime"],"sources":["/Users/soha/Desktop/lightbeam ny/node_modules/react-chromecast/node_modules/babel-plugin-transform-async-to-promises/helpers.js","/Users/soha/Desktop/lightbeam ny/node_modules/react-chromecast/src/context/castContext.ts","/Users/soha/Desktop/lightbeam ny/node_modules/react-chromecast/src/helpers/toWait.ts","/Users/soha/Desktop/lightbeam ny/node_modules/react-chromecast/src/components/CastProvider.tsx","/Users/soha/Desktop/lightbeam ny/node_modules/react-chromecast/src/hooks/useCast.ts","/Users/soha/Desktop/lightbeam ny/node_modules/react-chromecast/src/hooks/useMedia.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { createContext } from \"react\";\r\n\r\nimport CastReceiver from \"../interfaces/CastReceiver\";\r\n\r\nconst castContext = createContext<{\r\n  castReceiver?: CastReceiver;\r\n  castSender?: any;\r\n  setSession?: (p: any) => void;\r\n  session?: any;\r\n}>({});\r\n\r\nexport default castContext;\r\n","const wait = (time: number) =>\r\n  new Promise(res => {\r\n    setTimeout(res, time);\r\n  });\r\n\r\nexport default wait;\r\n","import * as React from 'react';\r\n\r\nimport { Helmet } from 'react-helmet';\r\nimport castContext from '../context/castContext';\r\n\r\nimport CastReceiver from '../interfaces/CastReceiver';\r\n\r\nimport toWait from '../helpers/toWait';\r\n\r\nconst { useState, useEffect } = React;\r\n\r\n/**\r\n * CastProvider is a component to use arround every component you go use with `react-chromecast` hooks\r\n *\r\n * Ex:\r\n * ```jsx\r\n *  import CastProvider from 'react-chromecast'\r\n *  function App () {\r\n *    return (\r\n *      <CastProvider>\r\n *        {\r\n *          // your components using react-chromecast hooks goes here\r\n *        }\r\n *      </CastProvider>\r\n *    )\r\n *  }\r\n * ```\r\n */\r\nfunction CastProvider({ children }: { children: any }) {\r\n  const [cast, setCast] = useState<{\r\n    castReceiver?: CastReceiver;\r\n    castSender?: any;\r\n  }>({});\r\n  const [session, setSession] = useState<any>({});\r\n  useEffect(() => {\r\n    (async () => {\r\n      let toBreak = false;\r\n      let tries = 15;\r\n      let castReceiver: CastReceiver;\r\n      let castSender: any;\r\n      while (true) {\r\n        try {\r\n          // @ts-ignore\r\n          castReceiver = window.chrome.cast as CastReceiver;\r\n          // @ts-ignore\r\n          castSender = window.cast.framework as any;\r\n          toBreak = true;\r\n        } catch (err) {\r\n          tries--;\r\n          if (!tries) {\r\n            toBreak = true;\r\n          }\r\n        } finally {\r\n          if (toBreak) break;\r\n        }\r\n        await toWait(95);\r\n      }\r\n      // @ts-ignore\r\n      if (tries !== 0 && !!castReceiver) {\r\n        setCast({\r\n          castReceiver,\r\n          castSender,\r\n        });\r\n      } else {\r\n        throw new Error(\"Can't Load castReceiver and\\\\or castSender\");\r\n      }\r\n    })();\r\n  }, []);\r\n  return (\r\n    <>\r\n      <Helmet>\r\n        <script src=\"//www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1\" />\r\n        <script src=\"//www.gstatic.com/cast/sdk/libs/receiver/2.0.0/cast_receiver.js\" />\r\n      </Helmet>\r\n      <castContext.Provider\r\n        value={{\r\n          ...cast,\r\n          session,\r\n          setSession,\r\n        }}\r\n      >\r\n        {children}\r\n      </castContext.Provider>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default CastProvider;\r\n","import { useEffect, useContext, useCallback, useState } from \"react\";\r\n\r\nimport castCtx from \"../context/castContext\";\r\n\r\nimport CastReceiver from \"../interfaces/CastReceiver\";\r\n\r\ninterface Props {\r\n  /**\r\n   * @param initialize_media_player - is media_receiver id\r\n   *\r\n   * if you pass auto_initialize as true you should pass this\r\n   *\r\n   * you should pass media_receiver id or 'DEFAULT_MEDIA_RECEIVER_APP_ID' to use default media receiver\r\n   */\r\n  initialize_media_player?: string;\r\n  /**\r\n   * @param auto_initialize - you can use this to auto initialize cast media player when castReceiver was define\r\n   *\r\n   * you not need to pass nothing to this if you go initialize by yourself\r\n   */\r\n  auto_initialize?: boolean;\r\n}\r\n\r\ninterface Cast {\r\n  /**\r\n   * Function to initialize cast player before connect to chromecast\r\n   *\r\n   * This function should wait for castReceiver\r\n   *\r\n   * @param media_player - you should pass media_receiver id or 'DEFAULT_MEDIA_RECEIVER_APP_ID' to use default media receiver\r\n   *\r\n   * Example:\r\n   * ```jsx\r\n   *  const cast = useCast()\r\n   *  useEffect(() => {\r\n   *    if(cast.castReceiver){\r\n   *      cast.initializeCast('DEFAULT_MEDIA_RECEIVER_APP_ID')\r\n   *    }\r\n   *  }, [cast.castReceiver])\r\n   * ```\r\n   */\r\n  initializeCast?: (media_player: string) => void;\r\n  /**\r\n   * Function to connect and disconnect client to chromecast\r\n   */\r\n  handleConnection: () => Promise<any>;\r\n  /**\r\n   * castReceiver object, from cast_receiver google lib\r\n   */\r\n  castReceiver?: CastReceiver;\r\n  /**\r\n   * castSender object, from cast_sender google lib\r\n   */\r\n  castSender?: any;\r\n  /**\r\n   * this inidicate if client is connected with chromecast or not\r\n   */\r\n  isConnect: boolean;\r\n}\r\n\r\nfunction useCast(props?: Props) {\r\n  const { initialize_media_player, auto_initialize } = props || {};\r\n\r\n  const { castReceiver, castSender, setSession } = useContext(castCtx);\r\n  const [cast, setCast] = useState({});\r\n  const [isConnect, setIsConnect] = useState(false);\r\n  const initiliazeCast = useCallback(\r\n    (media_player: string) => {\r\n      if (!castReceiver) return;\r\n      const sessionRequest = new castReceiver.SessionRequest(\r\n        castReceiver.media[media_player]\r\n      );\r\n      const apiConfig = new castReceiver.ApiConfig(\r\n        // @ts-ignore\r\n        sessionRequest,\r\n        (e: any) => {\r\n          // console.log(\"ss listener\", e);\r\n          if (setSession) setSession(e);\r\n          setIsConnect(true);\r\n        },\r\n        (e: any) => {\r\n          // console.log(\"rc listener\", e);\r\n        }\r\n      );\r\n      castReceiver.initialize(\r\n        apiConfig,\r\n        (e: any) => {\r\n          // console.log(\"init success\", e);\r\n        },\r\n        (e: any) => {\r\n          // console.log(\"init error\", e);\r\n        }\r\n      );\r\n      setCast({\r\n        castReceiver,\r\n      });\r\n    },\r\n    [castReceiver, setSession]\r\n  );\r\n\r\n  const handleConnection = useCallback(\r\n    () =>\r\n      new Promise((res, rej) => {\r\n        if (castReceiver) {\r\n          // @ts-ignore\r\n          castReceiver.requestSession(\r\n            (e: any) => {\r\n              if (setSession) setSession(e);\r\n              setIsConnect(true);\r\n              res(e);\r\n            },\r\n            (e: any) => {\r\n              setIsConnect(false);\r\n              if (!isConnect) return rej(e);\r\n              return res(null);\r\n            }\r\n          );\r\n        }\r\n      }),\r\n    [castReceiver, setSession]\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (castReceiver) {\r\n      setCast({ castReceiver });\r\n      if (auto_initialize && !initialize_media_player)\r\n        throw new Error(\r\n          \"if you pass auto_initialize: true, you should pass initialize_media_player\"\r\n        );\r\n      else if (auto_initialize && initialize_media_player)\r\n        initiliazeCast(initialize_media_player);\r\n    }\r\n  }, [castReceiver, castSender]);\r\n\r\n  const Cast = { ...cast, handleConnection, isConnect } as Cast;\r\n\r\n  if (!auto_initialize) {\r\n    Cast[\"initializeCast\"] = initiliazeCast;\r\n  }\r\n\r\n  return Cast;\r\n}\r\n\r\nexport default useCast;\r\n","import { useCallback, useContext, useState, useEffect } from \"react\";\r\n\r\nimport castCtx from \"../context/castContext\";\r\n\r\ninterface Media {\r\n  /**\r\n   * @function playMedia - function to add an media url to chromecast to play, you should use this to first media before add more with the add function, and before use play function\r\n   * @param src - this should be an media url acessible by chromecast\r\n   * @param autoplay - this inidicate if media will play after defined, default is true\r\n   */\r\n  playMedia: (src: string, autoplay?: boolean) => Promise<any>;\r\n  /**\r\n   * @function addMedia - function to add an media url to chromecast queue\r\n   * @param src - this should be an media url acessible by chromecast\r\n   */\r\n  addMedia: (src: string) => Promise<any>;\r\n  /**\r\n   * @function play - function to play media in chromecast\r\n   */\r\n  play: () => Promise<any>;\r\n  /**\r\n   * @function pause - function to pause media in chromecast\r\n   */\r\n  pause: () => Promise<any>;\r\n  /**\r\n   * this inidicate if is a media connected to chromecast\r\n   */\r\n  isMedia: boolean;\r\n  /**\r\n   * @function next - function to jump to next video in chromecast queue\r\n   */\r\n  next: () => Promise<any>;\r\n  /**\r\n   * @function prev - function to jump to prev video in chromecast queue\r\n   */\r\n  prev: () => Promise<any>;\r\n  /**\r\n   * @function to - function to jump to the time passed in seconds in chromecast playing video\r\n   * @param seconds - time in seconds to jump to\r\n   */\r\n  to: (seconds: number) => Promise<any>;\r\n}\r\n\r\nfunction useMedia() {\r\n  const { session, castReceiver } = useContext(castCtx);\r\n  const [media, setMedia] = useState<any>(null);\r\n  const [isMedia, setIsMedia] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (!session && isMedia) setIsMedia(false);\r\n  }, [session, isMedia]);\r\n\r\n  const playMedia = useCallback(\r\n    (src: string, autoplay?: boolean) =>\r\n      new Promise((res, rej) => {\r\n        if (!castReceiver || !session)\r\n          return rej(new Error(\"An Error occurred\"));\r\n\r\n        // @ts-ignore\r\n        const mediaInfo = new castReceiver.media.MediaInfo(src);\r\n        // @ts-ignore\r\n        const request = new castReceiver.media.LoadRequest(mediaInfo);\r\n\r\n        request.autoplay = autoplay || true;\r\n        session.loadMedia(\r\n          request,\r\n          (media: any) => {\r\n            setMedia(media);\r\n            setIsMedia(true);\r\n            res(media);\r\n          },\r\n          (err: any) => rej(err)\r\n        );\r\n      }),\r\n    [castReceiver, session]\r\n  );\r\n\r\n  const addMedia = useCallback(\r\n    async (src: string) => {\r\n      if (!castReceiver && !media) return;\r\n      // @ts-ignore\r\n      const mediaInfo = new castReceiver.media.MediaInfo(src);\r\n      // @ts-ignore\r\n      const queueItem = new castReceiver.media.QueueItem(mediaInfo);\r\n      await media.queueAppendItem(queueItem);\r\n    },\r\n    [media, castReceiver]\r\n  );\r\n\r\n  const play = useCallback(async () => {\r\n    if (!media) return;\r\n    await media.play();\r\n  }, [media]);\r\n\r\n  const pause = useCallback(async () => {\r\n    if (!media) return;\r\n    await media.pause();\r\n  }, [media]);\r\n\r\n  const prev = useCallback(async () => {\r\n    if (!media) return;\r\n    await media.queuePrev();\r\n  }, [media]);\r\n\r\n  const next = useCallback(async () => {\r\n    if (!media) return;\r\n    await media.queueNext();\r\n  }, [media]);\r\n\r\n  const to = useCallback(\r\n    async (seconds: number) => {\r\n      if (!media && !castReceiver) return;\r\n\r\n      // @ts-ignore\r\n      const seek = new castReceiver.media.SeekRequest();\r\n\r\n      seek.currentTime = seconds;\r\n\r\n      await media.seek(seek);\r\n    },\r\n    [media, castReceiver]\r\n  );\r\n\r\n  return {\r\n    playMedia,\r\n    addMedia,\r\n    play,\r\n    pause,\r\n    isMedia,\r\n    next,\r\n    prev,\r\n    to,\r\n  } as Media;\r\n}\r\n\r\nexport default useMedia;\r\n"],"mappings":";;;;;;;;;;;;;;;;;AAAA;AACO,MAAMA,KAAK,gBAAiB,YAAW;EAC7C,SAASA,KAAKA,CAAA,EAAG;EACjBA,KAAK,CAACC,SAAS,CAACC,IAAI,GAAG,UAASC,WAAW,EAAEC,UAAU,EAAE;IACxD,MAAMC,MAAM,GAAG,IAAIL,KAAK,EAAE;IAC1B,MAAMM,KAAK,GAAG,IAAI,CAACC,CAAC;IACpB,IAAID,KAAK,EAAE;MACV,MAAME,QAAQ,GAAGF,KAAK,GAAG,CAAC,GAAGH,WAAW,GAAGC,UAAU;MACrD,IAAII,QAAQ,EAAE;QACb,IAAI;UACHC,OAAO,CAACJ,MAAM,EAAE,CAAC,EAAEG,QAAQ,CAAC,IAAI,CAACE,CAAC,CAAC,CAAC;QACzC,CAAK,CAAC,OAAOC,CAAC,EAAE;UACXF,OAAO,CAACJ,MAAM,EAAE,CAAC,EAAEM,CAAC,CAAC;QAC1B;QACI,OAAON,MAAM;MACjB,CAAI,MAAM;QACN,OAAO,IAAI;MACf;IACA;IACE,IAAI,CAACO,CAAC,GAAG,UAASC,KAAK,EAAE;MACxB,IAAI;QACH,MAAMC,KAAK,GAAGD,KAAK,CAACH,CAAC;QACrB,IAAIG,KAAK,CAACN,CAAC,GAAG,CAAC,EAAE;UAChBE,OAAO,CAACJ,MAAM,EAAE,CAAC,EAAEF,WAAW,GAAGA,WAAW,CAACW,KAAK,CAAC,GAAGA,KAAK,CAAC;QACjE,CAAK,MAAM,IAAIV,UAAU,EAAE;UACtBK,OAAO,CAACJ,MAAM,EAAE,CAAC,EAAED,UAAU,CAACU,KAAK,CAAC,CAAC;QAC1C,CAAK,MAAM;UACNL,OAAO,CAACJ,MAAM,EAAE,CAAC,EAAES,KAAK,CAAC;QAC9B;MACA,CAAI,CAAC,OAAOH,CAAC,EAAE;QACXF,OAAO,CAACJ,MAAM,EAAE,CAAC,EAAEM,CAAC,CAAC;MACzB;IACA,CAAG;IACD,OAAON,MAAM;EACf;EACC,OAAOL,KAAK;AACb,CAAC,EAAG;;AAEJ;AACO,SAASS,OAAOA,CAACM,IAAI,EAAET,KAAK,EAAEQ,KAAK,EAAE;EAC3C,IAAI,CAACC,IAAI,CAACR,CAAC,EAAE;IACZ,IAAIO,KAAK,YAAYd,KAAK,EAAE;MAC3B,IAAIc,KAAK,CAACP,CAAC,EAAE;QACZ,IAAID,KAAK,GAAG,CAAC,EAAE;UACdA,KAAK,GAAGQ,KAAK,CAACP,CAAC;QACpB;QACIO,KAAK,GAAGA,KAAK,CAACJ,CAAC;MACnB,CAAI,MAAM;QACNI,KAAK,CAACF,CAAC,GAAGH,OAAO,CAACO,IAAI,CAAC,IAAI,EAAED,IAAI,EAAET,KAAK,CAAC;QACzC;MACJ;IACA;IACE,IAAIQ,KAAK,IAAIA,KAAK,CAACZ,IAAI,EAAE;MACxBY,KAAK,CAACZ,IAAI,CAACO,OAAO,CAACO,IAAI,CAAC,IAAI,EAAED,IAAI,EAAET,KAAK,CAAC,EAAEG,OAAO,CAACO,IAAI,CAAC,IAAI,EAAED,IAAI,EAAE,CAAC,CAAC,CAAC;MACxE;IACH;IACEA,IAAI,CAACR,CAAC,GAAGD,KAAK;IACdS,IAAI,CAACL,CAAC,GAAGI,KAAK;IACd,MAAMG,QAAQ,GAAGF,IAAI,CAACH,CAAC;IACvB,IAAIK,QAAQ,EAAE;MACbA,QAAQ,CAACF,IAAI,CAAC;IACjB;EACA;AACA;AAEO,SAASG,cAAcA,CAACC,QAAQ,EAAE;EACxC,OAAOA,QAAQ,YAAYnB,KAAK,IAAImB,QAAQ,CAACZ,CAAC,GAAG,CAAC;AACnD;AAiGO,MAAMa,eAAe,gBAAiB,OAAOC,MAAM,KAAK,WAAW,GAAIA,MAAM,CAACC,QAAQ,KAAKD,MAAM,CAACC,QAAQ,GAAGD,MAAM,CAAC,iBAAiB,CAAC,CAAC,GAAI,YAAY;AA6DvJ,MAAME,oBAAoB,gBAAiB,OAAOF,MAAM,KAAK,WAAW,GAAIA,MAAM,CAACG,aAAa,KAAKH,MAAM,CAACG,aAAa,GAAGH,MAAM,CAAC,sBAAsB,CAAC,CAAC,GAAI,iBAAiB;;AA6BvL;AACO,SAASI,IAAIA,CAACC,IAAI,EAAEC,MAAM,EAAEC,IAAI,EAAE;EACxC,IAAIC,KAAK;EACT,SAAS;IACR,IAAIC,cAAc,GAAGJ,IAAI,EAAE;IAC3B,IAAIR,cAAc,CAACY,cAAc,CAAC,EAAE;MACnCA,cAAc,GAAGA,cAAc,CAACpB,CAAC;IACpC;IACE,IAAI,CAACoB,cAAc,EAAE;MACpB,OAAOzB,MAAM;IAChB;IACE,IAAIyB,cAAc,CAAC5B,IAAI,EAAE;MACxB2B,KAAK,GAAG,CAAC;MACT;IACH;IACE,IAAIxB,MAAM,GAAGuB,IAAI,EAAE;IACnB,IAAIvB,MAAM,IAAIA,MAAM,CAACH,IAAI,EAAE;MAC1B,IAAIgB,cAAc,CAACb,MAAM,CAAC,EAAE;QAC3BA,MAAM,GAAGA,MAAM,CAACE,CAAC;MACrB,CAAI,MAAM;QACNsB,KAAK,GAAG,CAAC;QACT;MACJ;IACA;IACE,IAAIF,MAAM,EAAE;MACX,IAAII,WAAW,GAAGJ,MAAM,EAAE;MAC1B,IAAII,WAAW,IAAIA,WAAW,CAAC7B,IAAI,IAAI,CAACgB,cAAc,CAACa,WAAW,CAAC,EAAE;QACpEF,KAAK,GAAG,CAAC;QACT;MACJ;IACA;EACA;EACC,IAAId,IAAI,GAAG,IAAIf,KAAK,EAAE;EACtB,IAAIgC,MAAM,GAAGvB,OAAO,CAACO,IAAI,CAAC,IAAI,EAAED,IAAI,EAAE,CAAC,CAAC;EACxC,CAACc,KAAK,KAAK,CAAC,GAAGC,cAAc,CAAC5B,IAAI,CAAC+B,gBAAgB,CAAC,GAAGJ,KAAK,KAAK,CAAC,GAAGxB,MAAM,CAACH,IAAI,CAACgC,gBAAgB,CAAC,GAAGH,WAAW,CAAC7B,IAAI,CAACiC,kBAAkB,CAAC,EAAEjC,IAAI,CAAC,KAAK,CAAC,EAAE8B,MAAM,CAAC;EAC/J,OAAOjB,IAAI;EACX,SAASmB,gBAAgBA,CAACpB,KAAK,EAAE;IAChCT,MAAM,GAAGS,KAAK;IACd,GAAG;MACF,IAAIa,MAAM,EAAE;QACXI,WAAW,GAAGJ,MAAM,EAAE;QACtB,IAAII,WAAW,IAAIA,WAAW,CAAC7B,IAAI,IAAI,CAACgB,cAAc,CAACa,WAAW,CAAC,EAAE;UACpEA,WAAW,CAAC7B,IAAI,CAACiC,kBAAkB,CAAC,CAACjC,IAAI,CAAC,KAAK,CAAC,EAAE8B,MAAM,CAAC;UACzD;QACL;MACA;MACGF,cAAc,GAAGJ,IAAI,EAAE;MACvB,IAAI,CAACI,cAAc,IAAKZ,cAAc,CAACY,cAAc,CAAC,IAAI,CAACA,cAAc,CAACpB,CAAE,EAAE;QAC7ED,OAAO,CAACM,IAAI,EAAE,CAAC,EAAEV,MAAM,CAAC;QACxB;MACJ;MACG,IAAIyB,cAAc,CAAC5B,IAAI,EAAE;QACxB4B,cAAc,CAAC5B,IAAI,CAAC+B,gBAAgB,CAAC,CAAC/B,IAAI,CAAC,KAAK,CAAC,EAAE8B,MAAM,CAAC;QAC1D;MACJ;MACG3B,MAAM,GAAGuB,IAAI,EAAE;MACf,IAAIV,cAAc,CAACb,MAAM,CAAC,EAAE;QAC3BA,MAAM,GAAGA,MAAM,CAACK,CAAC;MACrB;IACA,CAAG,QAAQ,CAACL,MAAM,IAAI,CAACA,MAAM,CAACH,IAAI;IAChCG,MAAM,CAACH,IAAI,CAACgC,gBAAgB,CAAC,CAAChC,IAAI,CAAC,KAAK,CAAC,EAAE8B,MAAM,CAAC;EACpD;EACC,SAASC,gBAAgBA,CAACH,cAAc,EAAE;IACzC,IAAIA,cAAc,EAAE;MACnBzB,MAAM,GAAGuB,IAAI,EAAE;MACf,IAAIvB,MAAM,IAAIA,MAAM,CAACH,IAAI,EAAE;QAC1BG,MAAM,CAACH,IAAI,CAACgC,gBAAgB,CAAC,CAAChC,IAAI,CAAC,KAAK,CAAC,EAAE8B,MAAM,CAAC;MACtD,CAAI,MAAM;QACNE,gBAAgB,CAAC7B,MAAM,CAAC;MAC5B;IACA,CAAG,MAAM;MACNI,OAAO,CAACM,IAAI,EAAE,CAAC,EAAEV,MAAM,CAAC;IAC3B;EACA;EACC,SAAS8B,kBAAkBA,CAAA,EAAG;IAC7B,IAAIL,cAAc,GAAGJ,IAAI,EAAE,EAAE;MAC5B,IAAII,cAAc,CAAC5B,IAAI,EAAE;QACxB4B,cAAc,CAAC5B,IAAI,CAAC+B,gBAAgB,CAAC,CAAC/B,IAAI,CAAC,KAAK,CAAC,EAAE8B,MAAM,CAAC;MAC9D,CAAI,MAAM;QACNC,gBAAgB,CAACH,cAAc,CAAC;MACpC;IACA,CAAG,MAAM;MACNrB,OAAO,CAACM,IAAI,EAAE,CAAC,EAAEV,MAAM,CAAC;IAC3B;EACA;AACA;AC/UA,IAAM+B,WAAW,gBAAGC,aAAa,CAK9B,EAL8B,CAAjC;ACJA,IAAMC,IAAI,GAAG,SAAPA,IAAOA,CAACC,IAAD;EAAA,OACX,IAAIC,OAAJ,CAAY,UAAAC,GAAG;IACbC,UAAU,CAACD,GAAD,EAAMF,IAAN,CAAV;EACD,CAFD,CADW;AAAA,CAAb;ICSQI,QAAA,GAAwBC,UAAA;EAAdC,SAAA,GAAcC,WAAA;AAEhC;;;;;;;;;;;;;;;;;;AAiBA,SAASC,YAATA,CAAAC,IAAA;MAAwBC,QAAA,GAAAD,IAAA,CAAAC,QAAA;kBACEN,QAAQ,CAG7B,EAH6B;IAAzBO,IAAA,GAAAC,SAAA;IAAMC,OAAA,GAAAD,SAAA;mBAIiBR,QAAQ,CAAM,EAAN;IAA/BU,OAAA,GAAAC,UAAA;IAASC,UAAA,GAAAD,UAAA;EAChBT,SAAS,CAAC;IACR;MAAA;;cAuBMW,KAAK,KAAK,CAAV,IAAe,CAAC,CAACC,YAAA;YACnBL,OAAO,CAAC;cACNK,YAAY,EAAZA,YADM;cAENC,UAAU,EAAVA;YAFM,CAAD,CAAP;;YAKA,MAAM,IAAIC,KAAJ,CAAU,4CAAV,CAAN;;;;QA5BF,IAAIC,OAAO,GAAG,KAAd;QACA,IAAIJ,KAAK,GAAG,EAAZ;QACA,IAAIC,YAAJ;QACA,IAAIC,UAAJ;;;+BACa;UACX,IAAI;YACF;YACAD,YAAY,GAAGI,MAAM,CAACC,MAAP,CAAcZ,IAA7B,CAFE;;YAIFQ,UAAU,GAAGG,MAAM,CAACX,IAAP,CAAYa,SAAzB;YACAH,OAAO,GAAG,IAAV;UACD,CAND,CAME,OAAOI,GAAP,EAAY;YACZR,KAAK;YACL,IAAI,CAACA,KAAL,EAAY;cACVI,OAAO,GAAG,IAAV;YACD;UACF,CAXD,SAWU;YACR,IAAIA,OAAJ;cAAAK,WAAA;cAAA;YAAA;UACD;UAdU,OAAAzB,OAAA,CAAA0B,OAAA,CAeL5B,IAAM,CAAC,EAAD,CAfD,EAAApC,IAAA;QAgBZ;;MAUF,CA/BD,QAAAS,CAAA;QAAA6B,OAAA,CAAAR,MAAA,CAAArB,CAAA;MAAA;IAAA;EAgCD,CAjCQ,EAiCN,EAjCM,CAAT;EAkCA,OACEwD,aAAA,CAAAC,QAAA,QACED,aAAA,CAACE,MAAD,QACEF,aAAA;IAAQG,GAAG,EAAC;GAAZ,CADF,EAEEH,aAAA;IAAQG,GAAG,EAAC;GAAZ,CAFF,CADF,EAKEH,aAAA,CAAC/B,WAAW,CAACmC,QAAb;IACEzD,KAAK,EAAA0D,QAAA,KACAtB,IADA;MAEHG,OAAO,EAAPA,OAFG;MAGHE,UAAU,EAAVA;IAHG;GADP,EAOGN,QAPH,CALF,CADF;AAiBD;ACzBD,SAASwB,OAATA,CAAiBC,KAAjB;aACuDA,KAAK,IAAI;IAAtDC,uBAAA,GAAA3B,IAAA,CAAA2B,uBAAA;IAAyBC,eAAA,GAAA5B,IAAA,CAAA4B,eAAA;oBAEgBC,UAAU,CAACzC,WAAD;IAAnDqB,YAAA,GAAAqB,WAAA,CAAArB,YAAA;IAAcC,UAAA,GAAAoB,WAAA,CAAApB,UAAA;IAAYH,UAAA,GAAAuB,WAAA,CAAAvB,UAAA;kBACVX,UAAQ,CAAC,EAAD;IAAzBM,IAAA,GAAAC,SAAA;IAAMC,OAAA,GAAAD,SAAA;mBACqBP,UAAQ,CAAC,KAAD;IAAnCmC,SAAA,GAAAzB,UAAA;IAAW0B,YAAA,GAAA1B,UAAA;EAClB,IAAM2B,cAAc,GAAGC,WAAW,CAChC,UAACC,YAAD;IACE,IAAI,CAAC1B,YAAL,EAAmB;IACnB,IAAM2B,cAAc,GAAG,IAAI3B,YAAY,CAAC4B,cAAjB,CACrB5B,YAAY,CAAC6B,KAAb,CAAmBH,YAAnB,CADqB,CAAvB;IAGA,IAAMI,SAAS,GAAG,IAAI9B,YAAY,CAAC+B,SAAjB;IAAA;IAEhBJ,cAFgB,EAGhB,UAACzE,CAAD;MACE;MACA,IAAI4C,UAAJ,EAAgBA,UAAU,CAAC5C,CAAD,CAAV;MAChBqE,YAAY,CAAC,IAAD,CAAZ;IACD,CAPe,EAQhB,UAACrE,CAAD;IAAA,CARgB,CAAlB;IAYA8C,YAAY,CAACgC,UAAb,CACEF,SADF,EAEE,UAAC5E,CAAD;IAAA,CAFF,EAKE,UAACA,CAAD;IAAA,CALF;IASAyC,OAAO,CAAC;MACNK,YAAY,EAAZA;IADM,CAAD,CAAP;EAGD,CA9B+B,EA+BhC,CAACA,YAAD,EAAeF,UAAf,CA/BgC,CAAlC;EAkCA,IAAMmC,gBAAgB,GAAGR,WAAW,CAClC;IAAA,OACE,IAAI1C,OAAJ,CAAY,UAACC,GAAD,EAAMkD,GAAN;MACV,IAAIlC,YAAJ,EAAkB;QAChB;QACAA,YAAY,CAACmC,cAAb,CACE,UAACjF,CAAD;UACE,IAAI4C,UAAJ,EAAgBA,UAAU,CAAC5C,CAAD,CAAV;UAChBqE,YAAY,CAAC,IAAD,CAAZ;UACAvC,GAAG,CAAC9B,CAAD,CAAH;QACD,CALH,EAME,UAACA,CAAD;UACEqE,YAAY,CAAC,KAAD,CAAZ;UACA,IAAI,CAACD,SAAL,EAAgB,OAAOY,GAAG,CAAChF,CAAD,CAAV;UAChB,OAAO8B,GAAG,CAAC,IAAD,CAAV;QACD,CAVH;MAYD;IACF,CAhBD,CADF;EAAA,CADkC,EAmBlC,CAACgB,YAAD,EAAeF,UAAf,CAnBkC,CAApC;EAsBAT,WAAS,CAAC;IACR,IAAIW,YAAJ,EAAkB;MAChBL,OAAO,CAAC;QAAEK,YAAY,EAAZA;MAAF,CAAD,CAAP;MACA,IAAImB,eAAe,IAAI,CAACD,uBAAxB,EACE,MAAM,IAAIhB,KAAJ,CACJ,4EADI,CAAN,CADF,KAIK,IAAIiB,eAAe,IAAID,uBAAvB,EACHM,cAAc,CAACN,uBAAD,CAAd;IACH;EACF,CAVQ,EAUN,CAAClB,YAAD,EAAeC,UAAf,CAVM,CAAT;EAYA,IAAMmC,IAAI,GAAArB,QAAA,KAAQtB,IAAR;IAAcwC,gBAAgB,EAAhBA,gBAAd;IAAgCX,SAAS,EAATA;EAAhC,EAAV;EAEA,IAAI,CAACH,eAAL,EAAsB;IACpBiB,IAAI,CAAC,gBAAD,CAAJ,GAAyBZ,cAAzB;EACD;EAED,OAAOY,IAAP;AACD;AClGD,SAASC,QAATA,CAAA;oBACoCjB,UAAU,CAACzC,WAAD;IAApCiB,OAAA,GAAAyB,WAAA,CAAAzB,OAAA;IAASI,YAAA,GAAAqB,WAAA,CAAArB,YAAA;kBACSb,UAAQ,CAAM,IAAN;IAA3B0C,KAAA,GAAAnC,SAAA;IAAO4C,QAAA,GAAA5C,SAAA;mBACgBP,UAAQ,CAAC,KAAD;IAA/BoD,OAAA,GAAA1C,UAAA;IAAS2C,UAAA,GAAA3C,UAAA;EAEhBR,WAAS,CAAC;IACR,IAAI,CAACO,OAAD,IAAY2C,OAAhB,EAAyBC,UAAU,CAAC,KAAD,CAAV;EAC1B,CAFQ,EAEN,CAAC5C,OAAD,EAAU2C,OAAV,CAFM,CAAT;EAIA,IAAME,SAAS,GAAGhB,WAAW,CAC3B,UAACZ,GAAD,EAAc6B,QAAd;IAAA,OACE,IAAI3D,OAAJ,CAAY,UAACC,GAAD,EAAMkD,GAAN;MACV,IAAI,CAAClC,YAAD,IAAiB,CAACJ,OAAtB,EACE,OAAOsC,GAAG,CAAC,IAAIhC,KAAJ,CAAU,mBAAV,CAAD,CAAV;;MAGF,IAAMyC,SAAS,GAAG,IAAI3C,YAAY,CAAC6B,KAAb,CAAmBe,SAAvB,CAAiC/B,GAAjC,CAAlB;;MAEA,IAAMgC,OAAO,GAAG,IAAI7C,YAAY,CAAC6B,KAAb,CAAmBiB,WAAvB,CAAmCH,SAAnC,CAAhB;MAEAE,OAAO,CAACH,QAAR,GAAmBA,QAAQ,IAAI,IAA/B;MACA9C,OAAO,CAACmD,SAAR,CACEF,OADF,EAEE,UAAChB,KAAD;QACES,QAAQ,CAACT,KAAD,CAAR;QACAW,UAAU,CAAC,IAAD,CAAV;QACAxD,GAAG,CAAC6C,KAAD,CAAH;MACD,CANH,EAOE,UAACtB,GAAD;QAAA,OAAc2B,GAAG,CAAC3B,GAAD,CAAjB;MAAA,CAPF;IASD,CAnBD,CADF;EAAA,CAD2B,EAsB3B,CAACP,YAAD,EAAeJ,OAAf,CAtB2B,CAA7B;EAyBA,IAAMoD,QAAQ,GAAGvB,WAAW,WACnBZ,GADmB;IAAA;MAExB,IAAI,CAACb,YAAD,IAAiB,CAAC6B,KAAtB,EAA6B,OAAA9C,OAAA,CAAA0B,OAAA;;MAE7B,IAAMkC,SAAS,GAAG,IAAI3C,YAAY,CAAC6B,KAAb,CAAmBe,SAAvB,CAAiC/B,GAAjC,CAAlB;;MAEA,IAAMoC,SAAS,GAAG,IAAIjD,YAAY,CAAC6B,KAAb,CAAmBqB,SAAvB,CAAiCP,SAAjC,CAAlB;6BACMd,KAAK,CAACsB,eAAN,CAAsBF,SAAtB,GAAAxG,IAAA;IACP,CARyB,QAAAS,CAAA;MAAA,OAAA6B,OAAA,CAAAR,MAAA,CAAArB,CAAA;IAAA;EAAA,GAS1B,CAAC2E,KAAD,EAAQ7B,YAAR,CAT0B,CAA5B;EAYA,IAAMoD,IAAI,GAAG3B,WAAW;IAAA;MACtB,IAAI,CAACI,KAAL,EAAY,OAAA9C,OAAA,CAAA0B,OAAA;6BACNoB,KAAK,CAACuB,IAAN,IAAA3G,IAAA;IACP,CAHuB,QAAAS,CAAA;MAAA,OAAA6B,OAAA,CAAAR,MAAA,CAAArB,CAAA;IAAA;EAAA,GAGrB,CAAC2E,KAAD,CAHqB,CAAxB;EAKA,IAAMwB,KAAK,GAAG5B,WAAW;IAAA;MACvB,IAAI,CAACI,KAAL,EAAY,OAAA9C,OAAA,CAAA0B,OAAA;6BACNoB,KAAK,CAACwB,KAAN,IAAA5G,IAAA;IACP,CAHwB,QAAAS,CAAA;MAAA,OAAA6B,OAAA,CAAAR,MAAA,CAAArB,CAAA;IAAA;EAAA,GAGtB,CAAC2E,KAAD,CAHsB,CAAzB;EAKA,IAAMyB,IAAI,GAAG7B,WAAW;IAAA;MACtB,IAAI,CAACI,KAAL,EAAY,OAAA9C,OAAA,CAAA0B,OAAA;6BACNoB,KAAK,CAAC0B,SAAN,IAAA9G,IAAA;IACP,CAHuB,QAAAS,CAAA;MAAA,OAAA6B,OAAA,CAAAR,MAAA,CAAArB,CAAA;IAAA;EAAA,GAGrB,CAAC2E,KAAD,CAHqB,CAAxB;EAKA,IAAM2B,IAAI,GAAG/B,WAAW;IAAA;MACtB,IAAI,CAACI,KAAL,EAAY,OAAA9C,OAAA,CAAA0B,OAAA;6BACNoB,KAAK,CAAC4B,SAAN,IAAAhH,IAAA;IACP,CAHuB,QAAAS,CAAA;MAAA,OAAA6B,OAAA,CAAAR,MAAA,CAAArB,CAAA;IAAA;EAAA,GAGrB,CAAC2E,KAAD,CAHqB,CAAxB;EAKA,IAAM6B,EAAE,GAAGjC,WAAW,WACbkC,OADa;IAAA;MAElB,IAAI,CAAC9B,KAAD,IAAU,CAAC7B,YAAf,EAA6B,OAAAjB,OAAA,CAAA0B,OAAA;;MAG7B,IAAMmD,IAAI,GAAG,IAAI5D,YAAY,CAAC6B,KAAb,CAAmBgC,WAAvB,EAAb;MAEAD,IAAI,CAACE,WAAL,GAAmBH,OAAnB;6BAEM9B,KAAK,CAAC+B,IAAN,CAAWA,IAAX,GAAAnH,IAAA;IACP,CAVmB,QAAAS,CAAA;MAAA,OAAA6B,OAAA,CAAAR,MAAA,CAAArB,CAAA;IAAA;EAAA,GAWpB,CAAC2E,KAAD,EAAQ7B,YAAR,CAXoB,CAAtB;EAcA,OAAO;IACLyC,SAAS,EAATA,SADK;IAELO,QAAQ,EAARA,QAFK;IAGLI,IAAI,EAAJA,IAHK;IAILC,KAAK,EAALA,KAJK;IAKLd,OAAO,EAAPA,OALK;IAMLiB,IAAI,EAAJA,IANK;IAOLF,IAAI,EAAJA,IAPK;IAQLI,EAAE,EAAFA;EARK,CAAP;AAUD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}